/*
 * generated by Xtext 2.17.0.M1
 */
package lu.snt.serializer;

import com.google.inject.Inject;
import java.util.Set;
import lu.snt.services.SocratesGrammarAccess;
import lu.snt.socrates.AbsEXP;
import lu.snt.socrates.Basicexpression;
import lu.snt.socrates.ConstantDefinition;
import lu.snt.socrates.ConstantId;
import lu.snt.socrates.ConstantsDefinition;
import lu.snt.socrates.Cos;
import lu.snt.socrates.ExpressionAtom;
import lu.snt.socrates.Normexp;
import lu.snt.socrates.Oracle;
import lu.snt.socrates.Requirement;
import lu.snt.socrates.Signal;
import lu.snt.socrates.SignalID;
import lu.snt.socrates.Signalsdefinition;
import lu.snt.socrates.Sin;
import lu.snt.socrates.Socrates;
import lu.snt.socrates.SocratesPackage;
import lu.snt.socrates.Sqrt;
import lu.snt.socrates.Tvariable;
import lu.snt.socrates.atom;
import lu.snt.socrates.basicformulae;
import lu.snt.socrates.boundterm;
import lu.snt.socrates.existsformula;
import lu.snt.socrates.expression;
import lu.snt.socrates.expressionb;
import lu.snt.socrates.expressionprime;
import lu.snt.socrates.expressionterm;
import lu.snt.socrates.expressiontermprime;
import lu.snt.socrates.forAllformula;
import lu.snt.socrates.formula;
import lu.snt.socrates.formulab;
import lu.snt.socrates.formulabprime;
import lu.snt.socrates.negationformula;
import lu.snt.socrates.term;
import lu.snt.socrates.termprime;
import lu.snt.socrates.timedterm;
import lu.snt.socrates.value;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class SocratesSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private SocratesGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SocratesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SocratesPackage.ABS_EXP:
				sequence_AbsEXP(context, (AbsEXP) semanticObject); 
				return; 
			case SocratesPackage.BASICEXPRESSION:
				sequence_Basicexpression(context, (Basicexpression) semanticObject); 
				return; 
			case SocratesPackage.CONSTANT_DEFINITION:
				sequence_ConstantDefinition(context, (ConstantDefinition) semanticObject); 
				return; 
			case SocratesPackage.CONSTANT_ID:
				sequence_ConstantId(context, (ConstantId) semanticObject); 
				return; 
			case SocratesPackage.CONSTANTS_DEFINITION:
				sequence_ConstantsDefinition(context, (ConstantsDefinition) semanticObject); 
				return; 
			case SocratesPackage.COS:
				sequence_Cos(context, (Cos) semanticObject); 
				return; 
			case SocratesPackage.EXPRESSION_ATOM:
				sequence_ExpressionAtom(context, (ExpressionAtom) semanticObject); 
				return; 
			case SocratesPackage.NORMEXP:
				sequence_Normexp(context, (Normexp) semanticObject); 
				return; 
			case SocratesPackage.ORACLE:
				sequence_Oracle(context, (Oracle) semanticObject); 
				return; 
			case SocratesPackage.REQUIREMENT:
				sequence_Requirement(context, (Requirement) semanticObject); 
				return; 
			case SocratesPackage.SIGNAL:
				sequence_Signal(context, (Signal) semanticObject); 
				return; 
			case SocratesPackage.SIGNAL_ID:
				sequence_SignalID(context, (SignalID) semanticObject); 
				return; 
			case SocratesPackage.SIGNALSDEFINITION:
				sequence_Signalsdefinition(context, (Signalsdefinition) semanticObject); 
				return; 
			case SocratesPackage.SIN:
				sequence_Sin(context, (Sin) semanticObject); 
				return; 
			case SocratesPackage.SOCRATES:
				sequence_Socrates(context, (Socrates) semanticObject); 
				return; 
			case SocratesPackage.SQRT:
				sequence_Sqrt(context, (Sqrt) semanticObject); 
				return; 
			case SocratesPackage.TVARIABLE:
				sequence_Tvariable(context, (Tvariable) semanticObject); 
				return; 
			case SocratesPackage.ATOM:
				sequence_atom(context, (atom) semanticObject); 
				return; 
			case SocratesPackage.BASICFORMULAE:
				sequence_basicformulae(context, (basicformulae) semanticObject); 
				return; 
			case SocratesPackage.BOUNDTERM:
				sequence_boundterm(context, (boundterm) semanticObject); 
				return; 
			case SocratesPackage.EXISTSFORMULA:
				sequence_existsformula(context, (existsformula) semanticObject); 
				return; 
			case SocratesPackage.EXPRESSION:
				sequence_expression(context, (expression) semanticObject); 
				return; 
			case SocratesPackage.EXPRESSIONB:
				sequence_expressionb(context, (expressionb) semanticObject); 
				return; 
			case SocratesPackage.EXPRESSIONPRIME:
				sequence_expressionprime(context, (expressionprime) semanticObject); 
				return; 
			case SocratesPackage.EXPRESSIONTERM:
				sequence_expressionterm(context, (expressionterm) semanticObject); 
				return; 
			case SocratesPackage.EXPRESSIONTERMPRIME:
				sequence_expressiontermprime(context, (expressiontermprime) semanticObject); 
				return; 
			case SocratesPackage.FOR_ALLFORMULA:
				sequence_forAllformula(context, (forAllformula) semanticObject); 
				return; 
			case SocratesPackage.FORMULA:
				sequence_formula(context, (formula) semanticObject); 
				return; 
			case SocratesPackage.FORMULAB:
				sequence_formulab(context, (formulab) semanticObject); 
				return; 
			case SocratesPackage.FORMULABPRIME:
				sequence_formulabprime(context, (formulabprime) semanticObject); 
				return; 
			case SocratesPackage.NEGATIONFORMULA:
				sequence_negationformula(context, (negationformula) semanticObject); 
				return; 
			case SocratesPackage.TERM:
				sequence_term(context, (term) semanticObject); 
				return; 
			case SocratesPackage.TERMPRIME:
				sequence_termprime(context, (termprime) semanticObject); 
				return; 
			case SocratesPackage.TIMEDTERM:
				sequence_timedterm(context, (timedterm) semanticObject); 
				return; 
			case SocratesPackage.VALUE:
				sequence_value(context, (value) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbsEXP returns AbsEXP
	 *
	 * Constraint:
	 *     exp1=expression
	 */
	protected void sequence_AbsEXP(ISerializationContext context, AbsEXP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.ABS_EXP__EXP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.ABS_EXP__EXP1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsEXPAccess().getExp1ExpressionParserRuleCall_1_0(), semanticObject.getExp1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Basicexpression returns Basicexpression
	 *
	 * Constraint:
	 *     (
	 *         exp=Basicexpression | 
	 *         exp=AbsEXP | 
	 *         exp=Normexp | 
	 *         exp=Sin | 
	 *         exp=Cos | 
	 *         exp=Sqrt
	 *     )
	 */
	protected void sequence_Basicexpression(ISerializationContext context, Basicexpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstantDefinition returns ConstantDefinition
	 *
	 * Constraint:
	 *     (constantid=ConstantId value=number)
	 */
	protected void sequence_ConstantDefinition(ISerializationContext context, ConstantDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.CONSTANT_DEFINITION__CONSTANTID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.CONSTANT_DEFINITION__CONSTANTID));
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.CONSTANT_DEFINITION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.CONSTANT_DEFINITION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getConstantidConstantIdParserRuleCall_0_0(), semanticObject.getConstantid());
		feeder.accept(grammarAccess.getConstantDefinitionAccess().getValueNumberParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstantId returns ConstantId
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_ConstantId(ISerializationContext context, ConstantId semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.CONSTANT_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.CONSTANT_ID__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstantIdAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConstantsDefinition returns ConstantsDefinition
	 *
	 * Constraint:
	 *     (constants+=ConstantDefinition constants+=ConstantDefinition*)
	 */
	protected void sequence_ConstantsDefinition(ISerializationContext context, ConstantsDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Cos returns Cos
	 *
	 * Constraint:
	 *     exp1=expression
	 */
	protected void sequence_Cos(ISerializationContext context, Cos semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.COS__EXP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.COS__EXP1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCosAccess().getExp1ExpressionParserRuleCall_2_0(), semanticObject.getExp1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpressionAtom returns ExpressionAtom
	 *
	 * Constraint:
	 *     (exp=Signal | exp=expression | (op=SIGN exp=expression) | exp=value)
	 */
	protected void sequence_ExpressionAtom(ISerializationContext context, ExpressionAtom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Normexp returns Normexp
	 *
	 * Constraint:
	 *     exp1=expression
	 */
	protected void sequence_Normexp(ISerializationContext context, Normexp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.NORMEXP__EXP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.NORMEXP__EXP1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNormexpAccess().getExp1ExpressionParserRuleCall_1_0(), semanticObject.getExp1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Oracle returns Oracle
	 *
	 * Constraint:
	 *     (
	 *         modelName=ID 
	 *         path=PATH? 
	 *         reqname=ReqId 
	 *         signdef=Signalsdefinition 
	 *         constantDefinitions=ConstantsDefinition? 
	 *         requirement=Requirement
	 *     )
	 */
	protected void sequence_Oracle(ISerializationContext context, Oracle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Requirement returns Requirement
	 *
	 * Constraint:
	 *     formula=formula
	 */
	protected void sequence_Requirement(ISerializationContext context, Requirement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.REQUIREMENT__FORMULA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.REQUIREMENT__FORMULA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRequirementAccess().getFormulaFormulaParserRuleCall_4_0(), semanticObject.getFormula());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SignalID returns SignalID
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_SignalID(ISerializationContext context, SignalID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.SIGNAL_ID__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.SIGNAL_ID__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSignalIDAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Signal returns Signal
	 *
	 * Constraint:
	 *     (
	 *         (signalid=[SignalID|ID] timdedterm=timedterm) | 
	 *         (signalid=[SignalID|ID] indx1=number timdedterm=timedterm) | 
	 *         (signalid=[SignalID|ID] indx1=number indx2=number timdedterm=timedterm)
	 *     )
	 */
	protected void sequence_Signal(ISerializationContext context, Signal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Signalsdefinition returns Signalsdefinition
	 *
	 * Constraint:
	 *     (signals+=SignalID signals+=SignalID*)
	 */
	protected void sequence_Signalsdefinition(ISerializationContext context, Signalsdefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sin returns Sin
	 *
	 * Constraint:
	 *     exp1=expression
	 */
	protected void sequence_Sin(ISerializationContext context, Sin semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.SIN__EXP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.SIN__EXP1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSinAccess().getExp1ExpressionParserRuleCall_2_0(), semanticObject.getExp1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Socrates returns Socrates
	 *
	 * Constraint:
	 *     oracles+=Oracle+
	 */
	protected void sequence_Socrates(ISerializationContext context, Socrates semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sqrt returns Sqrt
	 *
	 * Constraint:
	 *     exp1=expression
	 */
	protected void sequence_Sqrt(ISerializationContext context, Sqrt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.SQRT__EXP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.SQRT__EXP1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSqrtAccess().getExp1ExpressionParserRuleCall_2_0(), semanticObject.getExp1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Tvariable returns Tvariable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Tvariable(ISerializationContext context, Tvariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.TVARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.TVARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTvariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     atom returns atom
	 *
	 * Constraint:
	 *     (f=formula | (s1=expression op=RELOP s2=expression))
	 */
	protected void sequence_atom(ISerializationContext context, atom semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     basicformulae returns basicformulae
	 *
	 * Constraint:
	 *     (f=negationformula | f=forAllformula | f=existsformula)
	 */
	protected void sequence_basicformulae(ISerializationContext context, basicformulae semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     boundterm returns boundterm
	 *
	 * Constraint:
	 *     (ref=Tvariable (l=LSQUARE | l=LPAREN) leftbound=timedterm rightbound=timedterm (r=RSQUARE | r=RPAREN))
	 */
	protected void sequence_boundterm(ISerializationContext context, boundterm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     existsformula returns existsformula
	 *
	 * Constraint:
	 *     (bound=boundterm existschild=formula)
	 */
	protected void sequence_existsformula(ISerializationContext context, existsformula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.EXISTSFORMULA__BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.EXISTSFORMULA__BOUND));
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.EXISTSFORMULA__EXISTSCHILD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.EXISTSFORMULA__EXISTSCHILD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistsformulaAccess().getBoundBoundtermParserRuleCall_1_0(), semanticObject.getBound());
		feeder.accept(grammarAccess.getExistsformulaAccess().getExistschildFormulaParserRuleCall_4_0(), semanticObject.getExistschild());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression returns expression
	 *
	 * Constraint:
	 *     expb=expressionb
	 */
	protected void sequence_expression(ISerializationContext context, expression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.EXPRESSION__EXPB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.EXPRESSION__EXPB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getExpbExpressionbParserRuleCall_0(), semanticObject.getExpb());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expressionb returns expressionb
	 *
	 * Constraint:
	 *     ((term=expressionterm expprime=expressionprime) | (term=expressionterm expprime=expressionprime))
	 */
	protected void sequence_expressionb(ISerializationContext context, expressionb semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expressionprime returns expressionprime
	 *
	 * Constraint:
	 *     ((op='+' | op='-') t2=expressionterm f=expressionprime)
	 */
	protected void sequence_expressionprime(ISerializationContext context, expressionprime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expressionterm returns expressionterm
	 *
	 * Constraint:
	 *     ((term=ExpressionAtom | term=Basicexpression) expprime=expressiontermprime)
	 */
	protected void sequence_expressionterm(ISerializationContext context, expressionterm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expressiontermprime returns expressiontermprime
	 *
	 * Constraint:
	 *     ((op='*' | op='/') t2=expressionterm f=expressiontermprime)
	 */
	protected void sequence_expressiontermprime(ISerializationContext context, expressiontermprime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     forAllformula returns forAllformula
	 *
	 * Constraint:
	 *     (bound=boundterm forallchild=formula)
	 */
	protected void sequence_forAllformula(ISerializationContext context, forAllformula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.FOR_ALLFORMULA__BOUND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.FOR_ALLFORMULA__BOUND));
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.FOR_ALLFORMULA__FORALLCHILD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.FOR_ALLFORMULA__FORALLCHILD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForAllformulaAccess().getBoundBoundtermParserRuleCall_1_0(), semanticObject.getBound());
		feeder.accept(grammarAccess.getForAllformulaAccess().getForallchildFormulaParserRuleCall_4_0(), semanticObject.getForallchild());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     formula returns formula
	 *
	 * Constraint:
	 *     (f=basicformulae | f=formulab)
	 */
	protected void sequence_formula(ISerializationContext context, formula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formulab returns formulab
	 *
	 * Constraint:
	 *     (a=term t=formulabprime)
	 */
	protected void sequence_formulab(ISerializationContext context, formulab semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.FORMULAB__A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.FORMULAB__A));
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.FORMULAB__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.FORMULAB__T));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormulabAccess().getATermParserRuleCall_0_0(), semanticObject.getA());
		feeder.accept(grammarAccess.getFormulabAccess().getTFormulabprimeParserRuleCall_1_0(), semanticObject.getT());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     formulabprime returns formulabprime
	 *
	 * Constraint:
	 *     ((op='or' | op='implies' | op='iff') t2=term f=formulabprime)
	 */
	protected void sequence_formulabprime(ISerializationContext context, formulabprime semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     negationformula returns negationformula
	 *
	 * Constraint:
	 *     negationchild=formula
	 */
	protected void sequence_negationformula(ISerializationContext context, negationformula semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.NEGATIONFORMULA__NEGATIONCHILD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.NEGATIONFORMULA__NEGATIONCHILD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNegationformulaAccess().getNegationchildFormulaParserRuleCall_1_0(), semanticObject.getNegationchild());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     term returns term
	 *
	 * Constraint:
	 *     (a=atom t=termprime)
	 */
	protected void sequence_term(ISerializationContext context, term semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.TERM__A) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.TERM__A));
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.TERM__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.TERM__T));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermAccess().getAAtomParserRuleCall_0_0(), semanticObject.getA());
		feeder.accept(grammarAccess.getTermAccess().getTTermprimeParserRuleCall_1_0(), semanticObject.getT());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     termprime returns termprime
	 *
	 * Constraint:
	 *     (op='and' t=term f1=termprime)
	 */
	protected void sequence_termprime(ISerializationContext context, termprime semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.TERMPRIME__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.TERMPRIME__OP));
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.TERMPRIME__T) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.TERMPRIME__T));
			if (transientValues.isValueTransient(semanticObject, SocratesPackage.Literals.TERMPRIME__F1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SocratesPackage.Literals.TERMPRIME__F1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermprimeAccess().getOpAndKeyword_0_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getTermprimeAccess().getTTermParserRuleCall_1_0(), semanticObject.getT());
		feeder.accept(grammarAccess.getTermprimeAccess().getF1TermprimeParserRuleCall_2_0(), semanticObject.getF1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     timedterm returns timedterm
	 *
	 * Constraint:
	 *     (inf=INF | number=number | ((ref=[ConstantId|ID] | ref=[Tvariable|ID]) ((op=PLUS | op=MINUS) value=value)?))
	 */
	protected void sequence_timedterm(ISerializationContext context, timedterm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     value returns value
	 *
	 * Constraint:
	 *     (exp=expression | number=number | ref=[ConstantId|ID] | float=FLOAT)
	 */
	protected void sequence_value(ISerializationContext context, value semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
