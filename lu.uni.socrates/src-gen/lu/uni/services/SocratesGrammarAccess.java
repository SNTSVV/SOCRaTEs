/*
 * generated by Xtext 2.19.0
 */
package lu.uni.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class SocratesGrammarAccess extends AbstractGrammarElementFinder {
	
	public class SocratesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Socrates");
		private final Assignment cOraclesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cOraclesOracleParserRuleCall_0 = (RuleCall)cOraclesAssignment.eContents().get(0);
		
		//// Socrates: generating Simulink Oracles for CPS RequiremenTs with uncErtainty
		//Socrates:
		//	oracles+=Oracle*;
		@Override public ParserRule getRule() { return rule; }
		
		//oracles+=Oracle*
		public Assignment getOraclesAssignment() { return cOraclesAssignment; }
		
		//Oracle
		public RuleCall getOraclesOracleParserRuleCall_0() { return cOraclesOracleParserRuleCall_0; }
	}
	public class OracleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Oracle");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cOracleKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Keyword cModelNameKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cModelNameAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cModelNameIDTerminalRuleCall_2_0 = (RuleCall)cModelNameAssignment_2.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cPathKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cPathAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cPathPATHParserRuleCall_4_1_0 = (RuleCall)cPathAssignment_4_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_4_2 = (Keyword)cGroup_4.eContents().get(2);
		private final Keyword cIDKeyword_5 = (Keyword)cGroup.eContents().get(5);
		private final Assignment cReqnameAssignment_6 = (Assignment)cGroup.eContents().get(6);
		private final RuleCall cReqnameReqIdParserRuleCall_6_0 = (RuleCall)cReqnameAssignment_6.eContents().get(0);
		private final Keyword cSemicolonKeyword_7 = (Keyword)cGroup.eContents().get(7);
		private final Assignment cSigndefAssignment_8 = (Assignment)cGroup.eContents().get(8);
		private final RuleCall cSigndefSignalsdefinitionParserRuleCall_8_0 = (RuleCall)cSigndefAssignment_8.eContents().get(0);
		private final Assignment cConstantDefinitionsAssignment_9 = (Assignment)cGroup.eContents().get(9);
		private final RuleCall cConstantDefinitionsConstantsDefinitionParserRuleCall_9_0 = (RuleCall)cConstantDefinitionsAssignment_9.eContents().get(0);
		private final Assignment cRequirementAssignment_10 = (Assignment)cGroup.eContents().get(10);
		private final RuleCall cRequirementRequirementParserRuleCall_10_0 = (RuleCall)cRequirementAssignment_10.eContents().get(0);
		
		//Oracle:
		//	'Oracle'
		//	'ModelName:' modelName=ID ';' ('Path:' path=PATH ';')?
		//	'ID:' reqname=ReqId ';'
		//	signdef=Signalsdefinition
		//	constantDefinitions=ConstantsDefinition?
		//	requirement=Requirement;
		@Override public ParserRule getRule() { return rule; }
		
		//'Oracle' 'ModelName:' modelName=ID ';' ('Path:' path=PATH ';')? 'ID:' reqname=ReqId ';' signdef=Signalsdefinition
		//constantDefinitions=ConstantsDefinition? requirement=Requirement
		public Group getGroup() { return cGroup; }
		
		//'Oracle'
		public Keyword getOracleKeyword_0() { return cOracleKeyword_0; }
		
		//'ModelName:'
		public Keyword getModelNameKeyword_1() { return cModelNameKeyword_1; }
		
		//modelName=ID
		public Assignment getModelNameAssignment_2() { return cModelNameAssignment_2; }
		
		//ID
		public RuleCall getModelNameIDTerminalRuleCall_2_0() { return cModelNameIDTerminalRuleCall_2_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
		
		//('Path:' path=PATH ';')?
		public Group getGroup_4() { return cGroup_4; }
		
		//'Path:'
		public Keyword getPathKeyword_4_0() { return cPathKeyword_4_0; }
		
		//path=PATH
		public Assignment getPathAssignment_4_1() { return cPathAssignment_4_1; }
		
		//PATH
		public RuleCall getPathPATHParserRuleCall_4_1_0() { return cPathPATHParserRuleCall_4_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_4_2() { return cSemicolonKeyword_4_2; }
		
		//'ID:'
		public Keyword getIDKeyword_5() { return cIDKeyword_5; }
		
		//reqname=ReqId
		public Assignment getReqnameAssignment_6() { return cReqnameAssignment_6; }
		
		//ReqId
		public RuleCall getReqnameReqIdParserRuleCall_6_0() { return cReqnameReqIdParserRuleCall_6_0; }
		
		//';'
		public Keyword getSemicolonKeyword_7() { return cSemicolonKeyword_7; }
		
		//signdef=Signalsdefinition
		public Assignment getSigndefAssignment_8() { return cSigndefAssignment_8; }
		
		//Signalsdefinition
		public RuleCall getSigndefSignalsdefinitionParserRuleCall_8_0() { return cSigndefSignalsdefinitionParserRuleCall_8_0; }
		
		//constantDefinitions=ConstantsDefinition?
		public Assignment getConstantDefinitionsAssignment_9() { return cConstantDefinitionsAssignment_9; }
		
		//ConstantsDefinition
		public RuleCall getConstantDefinitionsConstantsDefinitionParserRuleCall_9_0() { return cConstantDefinitionsConstantsDefinitionParserRuleCall_9_0; }
		
		//requirement=Requirement
		public Assignment getRequirementAssignment_10() { return cRequirementAssignment_10; }
		
		//Requirement
		public RuleCall getRequirementRequirementParserRuleCall_10_0() { return cRequirementRequirementParserRuleCall_10_0; }
	}
	public class RequirementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Requirement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDescriptionKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cDESCRIPTIONTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Keyword cSpecificationKeyword_3 = (Keyword)cGroup.eContents().get(3);
		private final Assignment cFormulaAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFormulaFormulaParserRuleCall_4_0 = (RuleCall)cFormulaAssignment_4.eContents().get(0);
		private final Keyword cSemicolonKeyword_5 = (Keyword)cGroup.eContents().get(5);
		
		//Requirement:
		//	'Description:' DESCRIPTION ';'
		//	'Specification:' formula=formula ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'Description:' DESCRIPTION ';' 'Specification:' formula=formula ';'
		public Group getGroup() { return cGroup; }
		
		//'Description:'
		public Keyword getDescriptionKeyword_0() { return cDescriptionKeyword_0; }
		
		//DESCRIPTION
		public RuleCall getDESCRIPTIONTerminalRuleCall_1() { return cDESCRIPTIONTerminalRuleCall_1; }
		
		//';'
		public Keyword getSemicolonKeyword_2() { return cSemicolonKeyword_2; }
		
		//'Specification:'
		public Keyword getSpecificationKeyword_3() { return cSpecificationKeyword_3; }
		
		//formula=formula
		public Assignment getFormulaAssignment_4() { return cFormulaAssignment_4; }
		
		//formula
		public RuleCall getFormulaFormulaParserRuleCall_4_0() { return cFormulaFormulaParserRuleCall_4_0; }
		
		//';'
		public Keyword getSemicolonKeyword_5() { return cSemicolonKeyword_5; }
	}
	public class ReqIdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.ReqId");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword c_Keyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final RuleCall cNumberParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Group cGroup_1_2 = (Group)cGroup_1.eContents().get(2);
		private final Keyword c_Keyword_1_2_0 = (Keyword)cGroup_1_2.eContents().get(0);
		private final RuleCall cNumberParserRuleCall_1_2_1 = (RuleCall)cGroup_1_2.eContents().get(1);
		
		//ReqId:
		//	ID ('_' number ('_' number)*)?;
		@Override public ParserRule getRule() { return rule; }
		
		//ID ('_' number ('_' number)*)?
		public Group getGroup() { return cGroup; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_0() { return cIDTerminalRuleCall_0; }
		
		//('_' number ('_' number)*)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'_'
		public Keyword get_Keyword_1_0() { return c_Keyword_1_0; }
		
		//number
		public RuleCall getNumberParserRuleCall_1_1() { return cNumberParserRuleCall_1_1; }
		
		//('_' number)*
		public Group getGroup_1_2() { return cGroup_1_2; }
		
		//'_'
		public Keyword get_Keyword_1_2_0() { return c_Keyword_1_2_0; }
		
		//number
		public RuleCall getNumberParserRuleCall_1_2_1() { return cNumberParserRuleCall_1_2_1; }
	}
	public class SignalsdefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Signalsdefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSignalsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSignalsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSignalsSignalIDParserRuleCall_1_0 = (RuleCall)cSignalsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cSignalsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cSignalsSignalIDParserRuleCall_2_1_0 = (RuleCall)cSignalsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//Signalsdefinition:
		//	'Signals' signals+=SignalID (',' signals+=SignalID)* ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'Signals' signals+=SignalID (',' signals+=SignalID)* ';'
		public Group getGroup() { return cGroup; }
		
		//'Signals'
		public Keyword getSignalsKeyword_0() { return cSignalsKeyword_0; }
		
		//signals+=SignalID
		public Assignment getSignalsAssignment_1() { return cSignalsAssignment_1; }
		
		//SignalID
		public RuleCall getSignalsSignalIDParserRuleCall_1_0() { return cSignalsSignalIDParserRuleCall_1_0; }
		
		//(',' signals+=SignalID)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//signals+=SignalID
		public Assignment getSignalsAssignment_2_1() { return cSignalsAssignment_2_1; }
		
		//SignalID
		public RuleCall getSignalsSignalIDParserRuleCall_2_1_0() { return cSignalsSignalIDParserRuleCall_2_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class ConstantsDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.ConstantsDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cConstantsKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cConstantsAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cConstantsConstantDefinitionParserRuleCall_1_0 = (RuleCall)cConstantsAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCommaKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cConstantsAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cConstantsConstantDefinitionParserRuleCall_2_1_0 = (RuleCall)cConstantsAssignment_2_1.eContents().get(0);
		private final Keyword cSemicolonKeyword_3 = (Keyword)cGroup.eContents().get(3);
		
		//ConstantsDefinition:
		//	'Constants' constants+=ConstantDefinition (',' constants+=ConstantDefinition)* ';';
		@Override public ParserRule getRule() { return rule; }
		
		//'Constants' constants+=ConstantDefinition (',' constants+=ConstantDefinition)* ';'
		public Group getGroup() { return cGroup; }
		
		//'Constants'
		public Keyword getConstantsKeyword_0() { return cConstantsKeyword_0; }
		
		//constants+=ConstantDefinition
		public Assignment getConstantsAssignment_1() { return cConstantsAssignment_1; }
		
		//ConstantDefinition
		public RuleCall getConstantsConstantDefinitionParserRuleCall_1_0() { return cConstantsConstantDefinitionParserRuleCall_1_0; }
		
		//(',' constants+=ConstantDefinition)*
		public Group getGroup_2() { return cGroup_2; }
		
		//','
		public Keyword getCommaKeyword_2_0() { return cCommaKeyword_2_0; }
		
		//constants+=ConstantDefinition
		public Assignment getConstantsAssignment_2_1() { return cConstantsAssignment_2_1; }
		
		//ConstantDefinition
		public RuleCall getConstantsConstantDefinitionParserRuleCall_2_1_0() { return cConstantsConstantDefinitionParserRuleCall_2_1_0; }
		
		//';'
		public Keyword getSemicolonKeyword_3() { return cSemicolonKeyword_3; }
	}
	public class ConstantDefinitionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.ConstantDefinition");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cConstantidAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cConstantidConstantIdParserRuleCall_0_0 = (RuleCall)cConstantidAssignment_0.eContents().get(0);
		private final RuleCall cEQParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cSIGNParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cValueAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cValueNumberParserRuleCall_3_0 = (RuleCall)cValueAssignment_3.eContents().get(0);
		
		//ConstantDefinition:
		//	constantid=ConstantId EQ SIGN? value=number;
		@Override public ParserRule getRule() { return rule; }
		
		//constantid=ConstantId EQ SIGN? value=number
		public Group getGroup() { return cGroup; }
		
		//constantid=ConstantId
		public Assignment getConstantidAssignment_0() { return cConstantidAssignment_0; }
		
		//ConstantId
		public RuleCall getConstantidConstantIdParserRuleCall_0_0() { return cConstantidConstantIdParserRuleCall_0_0; }
		
		//EQ
		public RuleCall getEQParserRuleCall_1() { return cEQParserRuleCall_1; }
		
		//SIGN?
		public RuleCall getSIGNParserRuleCall_2() { return cSIGNParserRuleCall_2; }
		
		//value=number
		public Assignment getValueAssignment_3() { return cValueAssignment_3; }
		
		//number
		public RuleCall getValueNumberParserRuleCall_3_0() { return cValueNumberParserRuleCall_3_0; }
	}
	public class SignalIDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.SignalID");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//SignalID:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ConstantIdElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.ConstantId");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//ConstantId:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class ForAllformulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.ForAllformula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cFORALLParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBoundBoundtermParserRuleCall_1_0 = (RuleCall)cBoundAssignment_1.eContents().get(0);
		private final RuleCall cCOLONParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cLPARENParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cForallchildAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cForallchildFormulaParserRuleCall_4_0 = (RuleCall)cForallchildAssignment_4.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//ForAllformula:
		//	FORALL bound=boundterm COLON LPAREN forallchild=formula RPAREN;
		@Override public ParserRule getRule() { return rule; }
		
		//FORALL bound=boundterm COLON LPAREN forallchild=formula RPAREN
		public Group getGroup() { return cGroup; }
		
		//FORALL
		public RuleCall getFORALLParserRuleCall_0() { return cFORALLParserRuleCall_0; }
		
		//bound=boundterm
		public Assignment getBoundAssignment_1() { return cBoundAssignment_1; }
		
		//boundterm
		public RuleCall getBoundBoundtermParserRuleCall_1_0() { return cBoundBoundtermParserRuleCall_1_0; }
		
		//COLON
		public RuleCall getCOLONParserRuleCall_2() { return cCOLONParserRuleCall_2; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_3() { return cLPARENParserRuleCall_3; }
		
		//forallchild=formula
		public Assignment getForallchildAssignment_4() { return cForallchildAssignment_4; }
		
		//formula
		public RuleCall getForallchildFormulaParserRuleCall_4_0() { return cForallchildFormulaParserRuleCall_4_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_5() { return cRPARENParserRuleCall_5; }
	}
	public class ExistsformulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Existsformula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cEXISTSParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cBoundAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cBoundBoundtermParserRuleCall_1_0 = (RuleCall)cBoundAssignment_1.eContents().get(0);
		private final RuleCall cCOLONParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final RuleCall cLPARENParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		private final Assignment cExistschildAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cExistschildFormulaParserRuleCall_4_0 = (RuleCall)cExistschildAssignment_4.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		//Existsformula:
		//	EXISTS bound=boundterm COLON LPAREN existschild=formula RPAREN;
		@Override public ParserRule getRule() { return rule; }
		
		//EXISTS bound=boundterm COLON LPAREN existschild=formula RPAREN
		public Group getGroup() { return cGroup; }
		
		//EXISTS
		public RuleCall getEXISTSParserRuleCall_0() { return cEXISTSParserRuleCall_0; }
		
		//bound=boundterm
		public Assignment getBoundAssignment_1() { return cBoundAssignment_1; }
		
		//boundterm
		public RuleCall getBoundBoundtermParserRuleCall_1_0() { return cBoundBoundtermParserRuleCall_1_0; }
		
		//COLON
		public RuleCall getCOLONParserRuleCall_2() { return cCOLONParserRuleCall_2; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_3() { return cLPARENParserRuleCall_3; }
		
		//existschild=formula
		public Assignment getExistschildAssignment_4() { return cExistschildAssignment_4; }
		
		//formula
		public RuleCall getExistschildFormulaParserRuleCall_4_0() { return cExistschildFormulaParserRuleCall_4_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_5() { return cRPARENParserRuleCall_5; }
	}
	public class TvariableElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Tvariable");
		private final Assignment cNameAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNameIDTerminalRuleCall_0 = (RuleCall)cNameAssignment.eContents().get(0);
		
		//Tvariable:
		//	name=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//name=ID
		public Assignment getNameAssignment() { return cNameAssignment; }
		
		//ID
		public RuleCall getNameIDTerminalRuleCall_0() { return cNameIDTerminalRuleCall_0; }
	}
	public class NegationformulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.negationformula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNOTParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cNegationchildAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNegationchildFormulaParserRuleCall_1_0 = (RuleCall)cNegationchildAssignment_1.eContents().get(0);
		
		//negationformula:
		//	NOT negationchild=formula;
		@Override public ParserRule getRule() { return rule; }
		
		//NOT negationchild=formula
		public Group getGroup() { return cGroup; }
		
		//NOT
		public RuleCall getNOTParserRuleCall_0() { return cNOTParserRuleCall_0; }
		
		//negationchild=formula
		public Assignment getNegationchildAssignment_1() { return cNegationchildAssignment_1; }
		
		//formula
		public RuleCall getNegationchildFormulaParserRuleCall_1_0() { return cNegationchildFormulaParserRuleCall_1_0; }
	}
	public class FormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.formula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFBasicformulaeParserRuleCall_0_0 = (RuleCall)cFAssignment_0.eContents().get(0);
		private final Assignment cFAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFFormulabParserRuleCall_1_0 = (RuleCall)cFAssignment_1.eContents().get(0);
		
		//formula:
		//	f=basicformulae | f=formulab;
		@Override public ParserRule getRule() { return rule; }
		
		//f=basicformulae | f=formulab
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//f=basicformulae
		public Assignment getFAssignment_0() { return cFAssignment_0; }
		
		//basicformulae
		public RuleCall getFBasicformulaeParserRuleCall_0_0() { return cFBasicformulaeParserRuleCall_0_0; }
		
		//f=formulab
		public Assignment getFAssignment_1() { return cFAssignment_1; }
		
		//formulab
		public RuleCall getFFormulabParserRuleCall_1_0() { return cFFormulabParserRuleCall_1_0; }
	}
	public class FormulabElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.formulab");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cATermParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Assignment cTAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTFormulabprimeParserRuleCall_1_0 = (RuleCall)cTAssignment_1.eContents().get(0);
		
		//formulab:
		//	a=term t=formulabprime;
		@Override public ParserRule getRule() { return rule; }
		
		//a=term t=formulabprime
		public Group getGroup() { return cGroup; }
		
		//a=term
		public Assignment getAAssignment_0() { return cAAssignment_0; }
		
		//term
		public RuleCall getATermParserRuleCall_0_0() { return cATermParserRuleCall_0_0; }
		
		//t=formulabprime
		public Assignment getTAssignment_1() { return cTAssignment_1; }
		
		//formulabprime
		public RuleCall getTFormulabprimeParserRuleCall_1_0() { return cTFormulabprimeParserRuleCall_1_0; }
	}
	public class FormulabprimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.formulabprime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cOpAlternatives_0_0 = (Alternatives)cOpAssignment_0.eContents().get(0);
		private final Keyword cOpOrKeyword_0_0_0 = (Keyword)cOpAlternatives_0_0.eContents().get(0);
		private final Keyword cOpImpliesKeyword_0_0_1 = (Keyword)cOpAlternatives_0_0.eContents().get(1);
		private final Keyword cOpIffKeyword_0_0_2 = (Keyword)cOpAlternatives_0_0.eContents().get(2);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2TermParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Assignment cFAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFFormulabprimeParserRuleCall_2_0 = (RuleCall)cFAssignment_2.eContents().get(0);
		
		//formulabprime:
		//	(op=('or' | 'implies' | 'iff') t2=term f=formulabprime)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(op=('or' | 'implies' | 'iff') t2=term f=formulabprime)?
		public Group getGroup() { return cGroup; }
		
		//op=('or' | 'implies' | 'iff')
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//('or' | 'implies' | 'iff')
		public Alternatives getOpAlternatives_0_0() { return cOpAlternatives_0_0; }
		
		//'or'
		public Keyword getOpOrKeyword_0_0_0() { return cOpOrKeyword_0_0_0; }
		
		//'implies'
		public Keyword getOpImpliesKeyword_0_0_1() { return cOpImpliesKeyword_0_0_1; }
		
		//'iff'
		public Keyword getOpIffKeyword_0_0_2() { return cOpIffKeyword_0_0_2; }
		
		//t2=term
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }
		
		//term
		public RuleCall getT2TermParserRuleCall_1_0() { return cT2TermParserRuleCall_1_0; }
		
		//f=formulabprime
		public Assignment getFAssignment_2() { return cFAssignment_2; }
		
		//formulabprime
		public RuleCall getFFormulabprimeParserRuleCall_2_0() { return cFFormulabprimeParserRuleCall_2_0; }
	}
	public class TermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.term");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cAAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cAAtomParserRuleCall_0_0 = (RuleCall)cAAssignment_0.eContents().get(0);
		private final Assignment cTAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTTermprimeParserRuleCall_1_0 = (RuleCall)cTAssignment_1.eContents().get(0);
		
		//term:
		//	a=atom t=termprime;
		@Override public ParserRule getRule() { return rule; }
		
		//a=atom t=termprime
		public Group getGroup() { return cGroup; }
		
		//a=atom
		public Assignment getAAssignment_0() { return cAAssignment_0; }
		
		//atom
		public RuleCall getAAtomParserRuleCall_0_0() { return cAAtomParserRuleCall_0_0; }
		
		//t=termprime
		public Assignment getTAssignment_1() { return cTAssignment_1; }
		
		//termprime
		public RuleCall getTTermprimeParserRuleCall_1_0() { return cTTermprimeParserRuleCall_1_0; }
	}
	public class TermprimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.termprime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cOpAndKeyword_0_0 = (Keyword)cOpAssignment_0.eContents().get(0);
		private final Assignment cTAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTTermParserRuleCall_1_0 = (RuleCall)cTAssignment_1.eContents().get(0);
		private final Assignment cF1Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cF1TermprimeParserRuleCall_2_0 = (RuleCall)cF1Assignment_2.eContents().get(0);
		
		//termprime:
		//	(op='and' t=term f1=termprime)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(op='and' t=term f1=termprime)?
		public Group getGroup() { return cGroup; }
		
		//op='and'
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//'and'
		public Keyword getOpAndKeyword_0_0() { return cOpAndKeyword_0_0; }
		
		//t=term
		public Assignment getTAssignment_1() { return cTAssignment_1; }
		
		//term
		public RuleCall getTTermParserRuleCall_1_0() { return cTTermParserRuleCall_1_0; }
		
		//f1=termprime
		public Assignment getF1Assignment_2() { return cF1Assignment_2; }
		
		//termprime
		public RuleCall getF1TermprimeParserRuleCall_2_0() { return cF1TermprimeParserRuleCall_2_0; }
	}
	public class ExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.expression");
		private final Assignment cExpbAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cExpbExpressionbParserRuleCall_0 = (RuleCall)cExpbAssignment.eContents().get(0);
		
		//expression:
		//	expb=expressionb;
		@Override public ParserRule getRule() { return rule; }
		
		////basicexpression=Basicexpression | 
		//expb=expressionb
		public Assignment getExpbAssignment() { return cExpbAssignment; }
		
		//expressionb
		public RuleCall getExpbExpressionbParserRuleCall_0() { return cExpbExpressionbParserRuleCall_0; }
	}
	public class ExpressionbElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.expressionb");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cTermAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cTermExpressiontermParserRuleCall_0_0_0 = (RuleCall)cTermAssignment_0_0.eContents().get(0);
		private final Assignment cExpprimeAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cExpprimeExpressionprimeParserRuleCall_0_1_0 = (RuleCall)cExpprimeAssignment_0_1.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cLPARENParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cTermAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermExpressiontermParserRuleCall_1_1_0 = (RuleCall)cTermAssignment_1_1.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Assignment cExpprimeAssignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cExpprimeExpressionprimeParserRuleCall_1_3_0 = (RuleCall)cExpprimeAssignment_1_3.eContents().get(0);
		
		//expressionb:
		//	term=expressionterm expprime=expressionprime | LPAREN term=expressionterm RPAREN expprime=expressionprime;
		@Override public ParserRule getRule() { return rule; }
		
		//term=expressionterm expprime=expressionprime | LPAREN term=expressionterm RPAREN expprime=expressionprime
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//term=expressionterm expprime=expressionprime
		public Group getGroup_0() { return cGroup_0; }
		
		//term=expressionterm
		public Assignment getTermAssignment_0_0() { return cTermAssignment_0_0; }
		
		//expressionterm
		public RuleCall getTermExpressiontermParserRuleCall_0_0_0() { return cTermExpressiontermParserRuleCall_0_0_0; }
		
		//expprime=expressionprime
		public Assignment getExpprimeAssignment_0_1() { return cExpprimeAssignment_0_1; }
		
		//expressionprime
		public RuleCall getExpprimeExpressionprimeParserRuleCall_0_1_0() { return cExpprimeExpressionprimeParserRuleCall_0_1_0; }
		
		//LPAREN term=expressionterm RPAREN expprime=expressionprime
		public Group getGroup_1() { return cGroup_1; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_1_0() { return cLPARENParserRuleCall_1_0; }
		
		//term=expressionterm
		public Assignment getTermAssignment_1_1() { return cTermAssignment_1_1; }
		
		//expressionterm
		public RuleCall getTermExpressiontermParserRuleCall_1_1_0() { return cTermExpressiontermParserRuleCall_1_1_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_1_2() { return cRPARENParserRuleCall_1_2; }
		
		//expprime=expressionprime
		public Assignment getExpprimeAssignment_1_3() { return cExpprimeAssignment_1_3; }
		
		//expressionprime
		public RuleCall getExpprimeExpressionprimeParserRuleCall_1_3_0() { return cExpprimeExpressionprimeParserRuleCall_1_3_0; }
	}
	public class ExpressionprimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.expressionprime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cOpAlternatives_0_0 = (Alternatives)cOpAssignment_0.eContents().get(0);
		private final Keyword cOpPlusSignKeyword_0_0_0 = (Keyword)cOpAlternatives_0_0.eContents().get(0);
		private final Keyword cOpHyphenMinusKeyword_0_0_1 = (Keyword)cOpAlternatives_0_0.eContents().get(1);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2ExpressiontermParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Assignment cFAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFExpressionprimeParserRuleCall_2_0 = (RuleCall)cFAssignment_2.eContents().get(0);
		
		//expressionprime:
		//	(op=('+' | '-') t2=expressionterm f=expressionprime)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(op=('+' | '-') t2=expressionterm f=expressionprime)?
		public Group getGroup() { return cGroup; }
		
		//op=('+' | '-')
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//('+' | '-')
		public Alternatives getOpAlternatives_0_0() { return cOpAlternatives_0_0; }
		
		//'+'
		public Keyword getOpPlusSignKeyword_0_0_0() { return cOpPlusSignKeyword_0_0_0; }
		
		//'-'
		public Keyword getOpHyphenMinusKeyword_0_0_1() { return cOpHyphenMinusKeyword_0_0_1; }
		
		//t2=expressionterm
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }
		
		//expressionterm
		public RuleCall getT2ExpressiontermParserRuleCall_1_0() { return cT2ExpressiontermParserRuleCall_1_0; }
		
		//f=expressionprime
		public Assignment getFAssignment_2() { return cFAssignment_2; }
		
		//expressionprime
		public RuleCall getFExpressionprimeParserRuleCall_2_0() { return cFExpressionprimeParserRuleCall_2_0; }
	}
	public class ExpressiontermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.expressionterm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTermAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cTermAlternatives_0_0 = (Alternatives)cTermAssignment_0.eContents().get(0);
		private final RuleCall cTermExpressionAtomParserRuleCall_0_0_0 = (RuleCall)cTermAlternatives_0_0.eContents().get(0);
		private final RuleCall cTermBasicexpressionParserRuleCall_0_0_1 = (RuleCall)cTermAlternatives_0_0.eContents().get(1);
		private final Assignment cExpprimeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExpprimeExpressiontermprimeParserRuleCall_1_0 = (RuleCall)cExpprimeAssignment_1.eContents().get(0);
		
		//expressionterm:
		//	term=(ExpressionAtom | Basicexpression) expprime=expressiontermprime;
		@Override public ParserRule getRule() { return rule; }
		
		//term=(ExpressionAtom | Basicexpression) expprime=expressiontermprime
		public Group getGroup() { return cGroup; }
		
		//term=(ExpressionAtom | Basicexpression)
		public Assignment getTermAssignment_0() { return cTermAssignment_0; }
		
		//(ExpressionAtom | Basicexpression)
		public Alternatives getTermAlternatives_0_0() { return cTermAlternatives_0_0; }
		
		//ExpressionAtom
		public RuleCall getTermExpressionAtomParserRuleCall_0_0_0() { return cTermExpressionAtomParserRuleCall_0_0_0; }
		
		//Basicexpression
		public RuleCall getTermBasicexpressionParserRuleCall_0_0_1() { return cTermBasicexpressionParserRuleCall_0_0_1; }
		
		//expprime=expressiontermprime
		public Assignment getExpprimeAssignment_1() { return cExpprimeAssignment_1; }
		
		//expressiontermprime
		public RuleCall getExpprimeExpressiontermprimeParserRuleCall_1_0() { return cExpprimeExpressiontermprimeParserRuleCall_1_0; }
	}
	public class ExpressiontermprimeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.expressiontermprime");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cOpAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Alternatives cOpAlternatives_0_0 = (Alternatives)cOpAssignment_0.eContents().get(0);
		private final Keyword cOpAsteriskKeyword_0_0_0 = (Keyword)cOpAlternatives_0_0.eContents().get(0);
		private final Keyword cOpSolidusKeyword_0_0_1 = (Keyword)cOpAlternatives_0_0.eContents().get(1);
		private final Assignment cT2Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cT2ExpressiontermParserRuleCall_1_0 = (RuleCall)cT2Assignment_1.eContents().get(0);
		private final Assignment cFAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cFExpressiontermprimeParserRuleCall_2_0 = (RuleCall)cFAssignment_2.eContents().get(0);
		
		//expressiontermprime:
		//	(op=('*' | '/') t2=expressionterm f=expressiontermprime)?;
		@Override public ParserRule getRule() { return rule; }
		
		//(op=('*' | '/') t2=expressionterm f=expressiontermprime)?
		public Group getGroup() { return cGroup; }
		
		//op=('*' | '/')
		public Assignment getOpAssignment_0() { return cOpAssignment_0; }
		
		//('*' | '/')
		public Alternatives getOpAlternatives_0_0() { return cOpAlternatives_0_0; }
		
		//'*'
		public Keyword getOpAsteriskKeyword_0_0_0() { return cOpAsteriskKeyword_0_0_0; }
		
		//'/'
		public Keyword getOpSolidusKeyword_0_0_1() { return cOpSolidusKeyword_0_0_1; }
		
		//t2=expressionterm
		public Assignment getT2Assignment_1() { return cT2Assignment_1; }
		
		//expressionterm
		public RuleCall getT2ExpressiontermParserRuleCall_1_0() { return cT2ExpressiontermParserRuleCall_1_0; }
		
		//f=expressiontermprime
		public Assignment getFAssignment_2() { return cFAssignment_2; }
		
		//expressiontermprime
		public RuleCall getFExpressiontermprimeParserRuleCall_2_0() { return cFExpressiontermprimeParserRuleCall_2_0; }
	}
	public class ExpressionAtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.ExpressionAtom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cExpAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cExpSignalParserRuleCall_0_0 = (RuleCall)cExpAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final RuleCall cLPARENParserRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cExpAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_1_1_0 = (RuleCall)cExpAssignment_1_1.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_1_2 = (RuleCall)cGroup_1.eContents().get(2);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cOpAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final RuleCall cOpSIGNParserRuleCall_2_0_0 = (RuleCall)cOpAssignment_2_0.eContents().get(0);
		private final Assignment cExpAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_2_1_0 = (RuleCall)cExpAssignment_2_1.eContents().get(0);
		private final Assignment cExpAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cExpValueParserRuleCall_3_0 = (RuleCall)cExpAssignment_3.eContents().get(0);
		
		//ExpressionAtom:
		//	exp=Signal | LPAREN exp=expression RPAREN | op=SIGN exp=expression | exp=value;
		@Override public ParserRule getRule() { return rule; }
		
		//exp=Signal | LPAREN exp=expression RPAREN | op=SIGN exp=expression | exp=value
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//exp=Signal
		public Assignment getExpAssignment_0() { return cExpAssignment_0; }
		
		//Signal
		public RuleCall getExpSignalParserRuleCall_0_0() { return cExpSignalParserRuleCall_0_0; }
		
		//LPAREN exp=expression RPAREN
		public Group getGroup_1() { return cGroup_1; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_1_0() { return cLPARENParserRuleCall_1_0; }
		
		//exp=expression
		public Assignment getExpAssignment_1_1() { return cExpAssignment_1_1; }
		
		//expression
		public RuleCall getExpExpressionParserRuleCall_1_1_0() { return cExpExpressionParserRuleCall_1_1_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_1_2() { return cRPARENParserRuleCall_1_2; }
		
		//op=SIGN exp=expression
		public Group getGroup_2() { return cGroup_2; }
		
		//op=SIGN
		public Assignment getOpAssignment_2_0() { return cOpAssignment_2_0; }
		
		//SIGN
		public RuleCall getOpSIGNParserRuleCall_2_0_0() { return cOpSIGNParserRuleCall_2_0_0; }
		
		//exp=expression
		public Assignment getExpAssignment_2_1() { return cExpAssignment_2_1; }
		
		//expression
		public RuleCall getExpExpressionParserRuleCall_2_1_0() { return cExpExpressionParserRuleCall_2_1_0; }
		
		//exp=value
		public Assignment getExpAssignment_3() { return cExpAssignment_3; }
		
		//value
		public RuleCall getExpValueParserRuleCall_3_0() { return cExpValueParserRuleCall_3_0; }
	}
	public class BasicexpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Basicexpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cLPARENParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cExpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cExpBasicexpressionParserRuleCall_0_1_0 = (RuleCall)cExpAssignment_0_1.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Assignment cExpAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cExpAbsEXPParserRuleCall_1_0 = (RuleCall)cExpAssignment_1.eContents().get(0);
		private final Assignment cExpAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cExpNormexpParserRuleCall_2_0 = (RuleCall)cExpAssignment_2.eContents().get(0);
		private final Assignment cExpAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cExpSinParserRuleCall_3_0 = (RuleCall)cExpAssignment_3.eContents().get(0);
		private final Assignment cExpAssignment_4 = (Assignment)cAlternatives.eContents().get(4);
		private final RuleCall cExpCosParserRuleCall_4_0 = (RuleCall)cExpAssignment_4.eContents().get(0);
		private final Assignment cExpAssignment_5 = (Assignment)cAlternatives.eContents().get(5);
		private final RuleCall cExpSqrtParserRuleCall_5_0 = (RuleCall)cExpAssignment_5.eContents().get(0);
		
		//Basicexpression:
		//	LPAREN exp=Basicexpression RPAREN | exp=AbsEXP | exp=Normexp | exp=Sin | exp=Cos | exp=Sqrt;
		@Override public ParserRule getRule() { return rule; }
		
		//LPAREN exp=Basicexpression RPAREN | exp=AbsEXP | exp=Normexp | exp=Sin | exp=Cos | exp=Sqrt
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LPAREN exp=Basicexpression RPAREN
		public Group getGroup_0() { return cGroup_0; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_0_0() { return cLPARENParserRuleCall_0_0; }
		
		//exp=Basicexpression
		public Assignment getExpAssignment_0_1() { return cExpAssignment_0_1; }
		
		//Basicexpression
		public RuleCall getExpBasicexpressionParserRuleCall_0_1_0() { return cExpBasicexpressionParserRuleCall_0_1_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_0_2() { return cRPARENParserRuleCall_0_2; }
		
		//exp=AbsEXP
		public Assignment getExpAssignment_1() { return cExpAssignment_1; }
		
		//AbsEXP
		public RuleCall getExpAbsEXPParserRuleCall_1_0() { return cExpAbsEXPParserRuleCall_1_0; }
		
		//exp=Normexp
		public Assignment getExpAssignment_2() { return cExpAssignment_2; }
		
		//Normexp
		public RuleCall getExpNormexpParserRuleCall_2_0() { return cExpNormexpParserRuleCall_2_0; }
		
		//exp=Sin
		public Assignment getExpAssignment_3() { return cExpAssignment_3; }
		
		//Sin
		public RuleCall getExpSinParserRuleCall_3_0() { return cExpSinParserRuleCall_3_0; }
		
		//exp=Cos
		public Assignment getExpAssignment_4() { return cExpAssignment_4; }
		
		//Cos
		public RuleCall getExpCosParserRuleCall_4_0() { return cExpCosParserRuleCall_4_0; }
		
		//exp=Sqrt
		public Assignment getExpAssignment_5() { return cExpAssignment_5; }
		
		//Sqrt
		public RuleCall getExpSqrtParserRuleCall_5_0() { return cExpSqrtParserRuleCall_5_0; }
	}
	public class BasicformulaeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.basicformulae");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cFAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cFNegationformulaParserRuleCall_0_0 = (RuleCall)cFAssignment_0.eContents().get(0);
		private final Assignment cFAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cFForAllformulaParserRuleCall_1_0 = (RuleCall)cFAssignment_1.eContents().get(0);
		private final Assignment cFAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final RuleCall cFExistsformulaParserRuleCall_2_0 = (RuleCall)cFAssignment_2.eContents().get(0);
		
		//basicformulae:
		//	f=negationformula
		//	| f=ForAllformula
		//	| f=Existsformula;
		@Override public ParserRule getRule() { return rule; }
		
		//f=negationformula | f=ForAllformula | f=Existsformula
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//f=negationformula
		public Assignment getFAssignment_0() { return cFAssignment_0; }
		
		//negationformula
		public RuleCall getFNegationformulaParserRuleCall_0_0() { return cFNegationformulaParserRuleCall_0_0; }
		
		//f=ForAllformula
		public Assignment getFAssignment_1() { return cFAssignment_1; }
		
		//ForAllformula
		public RuleCall getFForAllformulaParserRuleCall_1_0() { return cFForAllformulaParserRuleCall_1_0; }
		
		//f=Existsformula
		public Assignment getFAssignment_2() { return cFAssignment_2; }
		
		//Existsformula
		public RuleCall getFExistsformulaParserRuleCall_2_0() { return cFExistsformulaParserRuleCall_2_0; }
	}
	public class BoundtermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.boundterm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cRefAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cRefTvariableParserRuleCall_0_0 = (RuleCall)cRefAssignment_0.eContents().get(0);
		private final RuleCall cINParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Alternatives cAlternatives_2 = (Alternatives)cGroup.eContents().get(2);
		private final Assignment cLAssignment_2_0 = (Assignment)cAlternatives_2.eContents().get(0);
		private final RuleCall cLLSQUAREParserRuleCall_2_0_0 = (RuleCall)cLAssignment_2_0.eContents().get(0);
		private final Assignment cLAssignment_2_1 = (Assignment)cAlternatives_2.eContents().get(1);
		private final RuleCall cLLPARENParserRuleCall_2_1_0 = (RuleCall)cLAssignment_2_1.eContents().get(0);
		private final Assignment cLeftboundAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLeftboundTimedtermParserRuleCall_3_0 = (RuleCall)cLeftboundAssignment_3.eContents().get(0);
		private final RuleCall cCOMMAParserRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		private final Assignment cRightboundAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cRightboundTimedtermParserRuleCall_5_0 = (RuleCall)cRightboundAssignment_5.eContents().get(0);
		private final Alternatives cAlternatives_6 = (Alternatives)cGroup.eContents().get(6);
		private final Assignment cRAssignment_6_0 = (Assignment)cAlternatives_6.eContents().get(0);
		private final RuleCall cRRSQUAREParserRuleCall_6_0_0 = (RuleCall)cRAssignment_6_0.eContents().get(0);
		private final Assignment cRAssignment_6_1 = (Assignment)cAlternatives_6.eContents().get(1);
		private final RuleCall cRRPARENParserRuleCall_6_1_0 = (RuleCall)cRAssignment_6_1.eContents().get(0);
		
		//boundterm:
		//	ref=Tvariable IN (l=LSQUARE | l=LPAREN) leftbound=timedterm COMMA rightbound=timedterm (r=RSQUARE | r=RPAREN);
		@Override public ParserRule getRule() { return rule; }
		
		//ref=Tvariable IN (l=LSQUARE | l=LPAREN) leftbound=timedterm COMMA rightbound=timedterm (r=RSQUARE | r=RPAREN)
		public Group getGroup() { return cGroup; }
		
		//ref=Tvariable
		public Assignment getRefAssignment_0() { return cRefAssignment_0; }
		
		//Tvariable
		public RuleCall getRefTvariableParserRuleCall_0_0() { return cRefTvariableParserRuleCall_0_0; }
		
		//IN
		public RuleCall getINParserRuleCall_1() { return cINParserRuleCall_1; }
		
		//(l=LSQUARE | l=LPAREN)
		public Alternatives getAlternatives_2() { return cAlternatives_2; }
		
		//l=LSQUARE
		public Assignment getLAssignment_2_0() { return cLAssignment_2_0; }
		
		//LSQUARE
		public RuleCall getLLSQUAREParserRuleCall_2_0_0() { return cLLSQUAREParserRuleCall_2_0_0; }
		
		//l=LPAREN
		public Assignment getLAssignment_2_1() { return cLAssignment_2_1; }
		
		//LPAREN
		public RuleCall getLLPARENParserRuleCall_2_1_0() { return cLLPARENParserRuleCall_2_1_0; }
		
		//leftbound=timedterm
		public Assignment getLeftboundAssignment_3() { return cLeftboundAssignment_3; }
		
		//timedterm
		public RuleCall getLeftboundTimedtermParserRuleCall_3_0() { return cLeftboundTimedtermParserRuleCall_3_0; }
		
		//COMMA
		public RuleCall getCOMMAParserRuleCall_4() { return cCOMMAParserRuleCall_4; }
		
		//rightbound=timedterm
		public Assignment getRightboundAssignment_5() { return cRightboundAssignment_5; }
		
		//timedterm
		public RuleCall getRightboundTimedtermParserRuleCall_5_0() { return cRightboundTimedtermParserRuleCall_5_0; }
		
		//(r=RSQUARE | r=RPAREN)
		public Alternatives getAlternatives_6() { return cAlternatives_6; }
		
		//r=RSQUARE
		public Assignment getRAssignment_6_0() { return cRAssignment_6_0; }
		
		//RSQUARE
		public RuleCall getRRSQUAREParserRuleCall_6_0_0() { return cRRSQUAREParserRuleCall_6_0_0; }
		
		//r=RPAREN
		public Assignment getRAssignment_6_1() { return cRAssignment_6_1; }
		
		//RPAREN
		public RuleCall getRRPARENParserRuleCall_6_1_0() { return cRRPARENParserRuleCall_6_1_0; }
	}
	public class TimedtermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.timedterm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cInfAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cInfINFParserRuleCall_0_0 = (RuleCall)cInfAssignment_0.eContents().get(0);
		private final Assignment cNumberAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNumberNumberParserRuleCall_1_0 = (RuleCall)cNumberAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Alternatives cAlternatives_2_0 = (Alternatives)cGroup_2.eContents().get(0);
		private final Assignment cRefAssignment_2_0_0 = (Assignment)cAlternatives_2_0.eContents().get(0);
		private final CrossReference cRefConstantIdCrossReference_2_0_0_0 = (CrossReference)cRefAssignment_2_0_0.eContents().get(0);
		private final RuleCall cRefConstantIdIDTerminalRuleCall_2_0_0_0_1 = (RuleCall)cRefConstantIdCrossReference_2_0_0_0.eContents().get(1);
		private final Assignment cRefAssignment_2_0_1 = (Assignment)cAlternatives_2_0.eContents().get(1);
		private final CrossReference cRefTvariableCrossReference_2_0_1_0 = (CrossReference)cRefAssignment_2_0_1.eContents().get(0);
		private final RuleCall cRefTvariableIDTerminalRuleCall_2_0_1_0_1 = (RuleCall)cRefTvariableCrossReference_2_0_1_0.eContents().get(1);
		private final Group cGroup_2_1 = (Group)cGroup_2.eContents().get(1);
		private final Assignment cOpAssignment_2_1_0 = (Assignment)cGroup_2_1.eContents().get(0);
		private final Alternatives cOpAlternatives_2_1_0_0 = (Alternatives)cOpAssignment_2_1_0.eContents().get(0);
		private final RuleCall cOpPLUSParserRuleCall_2_1_0_0_0 = (RuleCall)cOpAlternatives_2_1_0_0.eContents().get(0);
		private final RuleCall cOpMINUSParserRuleCall_2_1_0_0_1 = (RuleCall)cOpAlternatives_2_1_0_0.eContents().get(1);
		private final Assignment cValueAssignment_2_1_1 = (Assignment)cGroup_2_1.eContents().get(1);
		private final RuleCall cValueValueParserRuleCall_2_1_1_0 = (RuleCall)cValueAssignment_2_1_1.eContents().get(0);
		
		//timedterm:
		//	inf=INF
		//	| number=number
		//	| (ref=[ConstantId] | ref=[Tvariable]) (op=(PLUS | MINUS) value=value)?;
		@Override public ParserRule getRule() { return rule; }
		
		//inf=INF | number=number | (ref=[ConstantId] | ref=[Tvariable]) (op=(PLUS | MINUS) value=value)?
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//inf=INF
		public Assignment getInfAssignment_0() { return cInfAssignment_0; }
		
		//INF
		public RuleCall getInfINFParserRuleCall_0_0() { return cInfINFParserRuleCall_0_0; }
		
		//number=number
		public Assignment getNumberAssignment_1() { return cNumberAssignment_1; }
		
		//number
		public RuleCall getNumberNumberParserRuleCall_1_0() { return cNumberNumberParserRuleCall_1_0; }
		
		//(ref=[ConstantId] | ref=[Tvariable]) (op=(PLUS | MINUS) value=value)?
		public Group getGroup_2() { return cGroup_2; }
		
		//(ref=[ConstantId] | ref=[Tvariable])
		public Alternatives getAlternatives_2_0() { return cAlternatives_2_0; }
		
		//ref=[ConstantId]
		public Assignment getRefAssignment_2_0_0() { return cRefAssignment_2_0_0; }
		
		//[ConstantId]
		public CrossReference getRefConstantIdCrossReference_2_0_0_0() { return cRefConstantIdCrossReference_2_0_0_0; }
		
		//ID
		public RuleCall getRefConstantIdIDTerminalRuleCall_2_0_0_0_1() { return cRefConstantIdIDTerminalRuleCall_2_0_0_0_1; }
		
		//ref=[Tvariable]
		public Assignment getRefAssignment_2_0_1() { return cRefAssignment_2_0_1; }
		
		//[Tvariable]
		public CrossReference getRefTvariableCrossReference_2_0_1_0() { return cRefTvariableCrossReference_2_0_1_0; }
		
		//ID
		public RuleCall getRefTvariableIDTerminalRuleCall_2_0_1_0_1() { return cRefTvariableIDTerminalRuleCall_2_0_1_0_1; }
		
		//(op=(PLUS | MINUS) value=value)?
		public Group getGroup_2_1() { return cGroup_2_1; }
		
		//op=(PLUS | MINUS)
		public Assignment getOpAssignment_2_1_0() { return cOpAssignment_2_1_0; }
		
		//(PLUS | MINUS)
		public Alternatives getOpAlternatives_2_1_0_0() { return cOpAlternatives_2_1_0_0; }
		
		//PLUS
		public RuleCall getOpPLUSParserRuleCall_2_1_0_0_0() { return cOpPLUSParserRuleCall_2_1_0_0_0; }
		
		//MINUS
		public RuleCall getOpMINUSParserRuleCall_2_1_0_0_1() { return cOpMINUSParserRuleCall_2_1_0_0_1; }
		
		//value=value
		public Assignment getValueAssignment_2_1_1() { return cValueAssignment_2_1_1; }
		
		//value
		public RuleCall getValueValueParserRuleCall_2_1_1_0() { return cValueValueParserRuleCall_2_1_1_0; }
	}
	public class AtomElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.atom");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cLPARENParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cFAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cFFormulaParserRuleCall_0_1_0 = (RuleCall)cFAssignment_0_1.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Keyword cLeftCurlyBracketKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cS1Assignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cS1ExpressionParserRuleCall_1_1_0 = (RuleCall)cS1Assignment_1_1.eContents().get(0);
		private final Assignment cOpAssignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cOpRELOPParserRuleCall_1_2_0 = (RuleCall)cOpAssignment_1_2.eContents().get(0);
		private final Assignment cS2Assignment_1_3 = (Assignment)cGroup_1.eContents().get(3);
		private final RuleCall cS2ExpressionParserRuleCall_1_3_0 = (RuleCall)cS2Assignment_1_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_1_4 = (Keyword)cGroup_1.eContents().get(4);
		
		//atom:
		//	LPAREN f=formula RPAREN |
		//	'{' s1=expression op=RELOP s2=expression "}";
		@Override public ParserRule getRule() { return rule; }
		
		//LPAREN f=formula RPAREN | '{' s1=expression op=RELOP s2=expression "}"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LPAREN f=formula RPAREN
		public Group getGroup_0() { return cGroup_0; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_0_0() { return cLPARENParserRuleCall_0_0; }
		
		//f=formula
		public Assignment getFAssignment_0_1() { return cFAssignment_0_1; }
		
		//formula
		public RuleCall getFFormulaParserRuleCall_0_1_0() { return cFFormulaParserRuleCall_0_1_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_0_2() { return cRPARENParserRuleCall_0_2; }
		
		//'{' s1=expression op=RELOP s2=expression "}"
		public Group getGroup_1() { return cGroup_1; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1_0() { return cLeftCurlyBracketKeyword_1_0; }
		
		//s1=expression
		public Assignment getS1Assignment_1_1() { return cS1Assignment_1_1; }
		
		//expression
		public RuleCall getS1ExpressionParserRuleCall_1_1_0() { return cS1ExpressionParserRuleCall_1_1_0; }
		
		//op=RELOP
		public Assignment getOpAssignment_1_2() { return cOpAssignment_1_2; }
		
		//RELOP
		public RuleCall getOpRELOPParserRuleCall_1_2_0() { return cOpRELOPParserRuleCall_1_2_0; }
		
		//s2=expression
		public Assignment getS2Assignment_1_3() { return cS2Assignment_1_3; }
		
		//expression
		public RuleCall getS2ExpressionParserRuleCall_1_3_0() { return cS2ExpressionParserRuleCall_1_3_0; }
		
		//"}"
		public Keyword getRightCurlyBracketKeyword_1_4() { return cRightCurlyBracketKeyword_1_4; }
	}
	public class ValueElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.value");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final RuleCall cLPARENParserRuleCall_0_0 = (RuleCall)cGroup_0.eContents().get(0);
		private final Assignment cExpAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final RuleCall cExpExpressionParserRuleCall_0_1_0 = (RuleCall)cExpAssignment_0_1.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_0_2 = (RuleCall)cGroup_0.eContents().get(2);
		private final Assignment cNumberAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cNumberNumberParserRuleCall_1_0 = (RuleCall)cNumberAssignment_1.eContents().get(0);
		private final Assignment cRefAssignment_2 = (Assignment)cAlternatives.eContents().get(2);
		private final CrossReference cRefConstantIdCrossReference_2_0 = (CrossReference)cRefAssignment_2.eContents().get(0);
		private final RuleCall cRefConstantIdIDTerminalRuleCall_2_0_1 = (RuleCall)cRefConstantIdCrossReference_2_0.eContents().get(1);
		private final Assignment cFloatAssignment_3 = (Assignment)cAlternatives.eContents().get(3);
		private final RuleCall cFloatFLOATParserRuleCall_3_0 = (RuleCall)cFloatAssignment_3.eContents().get(0);
		
		//value:
		//	LPAREN exp=expression RPAREN | number=number
		//	| ref=[ConstantId] | float=FLOAT;
		@Override public ParserRule getRule() { return rule; }
		
		//LPAREN exp=expression RPAREN | number=number | ref=[ConstantId] | float=FLOAT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//LPAREN exp=expression RPAREN
		public Group getGroup_0() { return cGroup_0; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_0_0() { return cLPARENParserRuleCall_0_0; }
		
		//exp=expression
		public Assignment getExpAssignment_0_1() { return cExpAssignment_0_1; }
		
		//expression
		public RuleCall getExpExpressionParserRuleCall_0_1_0() { return cExpExpressionParserRuleCall_0_1_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_0_2() { return cRPARENParserRuleCall_0_2; }
		
		//number=number
		public Assignment getNumberAssignment_1() { return cNumberAssignment_1; }
		
		//number
		public RuleCall getNumberNumberParserRuleCall_1_0() { return cNumberNumberParserRuleCall_1_0; }
		
		//ref=[ConstantId]
		public Assignment getRefAssignment_2() { return cRefAssignment_2; }
		
		//[ConstantId]
		public CrossReference getRefConstantIdCrossReference_2_0() { return cRefConstantIdCrossReference_2_0; }
		
		//ID
		public RuleCall getRefConstantIdIDTerminalRuleCall_2_0_1() { return cRefConstantIdIDTerminalRuleCall_2_0_1; }
		
		//float=FLOAT
		public Assignment getFloatAssignment_3() { return cFloatAssignment_3; }
		
		//FLOAT
		public RuleCall getFloatFLOATParserRuleCall_3_0() { return cFloatFLOATParserRuleCall_3_0; }
	}
	public class SignalElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Signal");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Assignment cSignalidAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final CrossReference cSignalidSignalIDCrossReference_0_0_0 = (CrossReference)cSignalidAssignment_0_0.eContents().get(0);
		private final RuleCall cSignalidSignalIDIDTerminalRuleCall_0_0_0_1 = (RuleCall)cSignalidSignalIDCrossReference_0_0_0.eContents().get(1);
		private final RuleCall cLPARENParserRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Assignment cTimdedtermAssignment_0_2 = (Assignment)cGroup_0.eContents().get(2);
		private final RuleCall cTimdedtermTimedtermParserRuleCall_0_2_0 = (RuleCall)cTimdedtermAssignment_0_2.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_0_3 = (RuleCall)cGroup_0.eContents().get(3);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cSignalidAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final CrossReference cSignalidSignalIDCrossReference_1_0_0 = (CrossReference)cSignalidAssignment_1_0.eContents().get(0);
		private final RuleCall cSignalidSignalIDIDTerminalRuleCall_1_0_0_1 = (RuleCall)cSignalidSignalIDCrossReference_1_0_0.eContents().get(1);
		private final RuleCall cLSQUAREParserRuleCall_1_1 = (RuleCall)cGroup_1.eContents().get(1);
		private final Assignment cIndx1Assignment_1_2 = (Assignment)cGroup_1.eContents().get(2);
		private final RuleCall cIndx1NumberParserRuleCall_1_2_0 = (RuleCall)cIndx1Assignment_1_2.eContents().get(0);
		private final RuleCall cRSQUAREParserRuleCall_1_3 = (RuleCall)cGroup_1.eContents().get(3);
		private final RuleCall cLPARENParserRuleCall_1_4 = (RuleCall)cGroup_1.eContents().get(4);
		private final Assignment cTimdedtermAssignment_1_5 = (Assignment)cGroup_1.eContents().get(5);
		private final RuleCall cTimdedtermTimedtermParserRuleCall_1_5_0 = (RuleCall)cTimdedtermAssignment_1_5.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_1_6 = (RuleCall)cGroup_1.eContents().get(6);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final Assignment cSignalidAssignment_2_0 = (Assignment)cGroup_2.eContents().get(0);
		private final CrossReference cSignalidSignalIDCrossReference_2_0_0 = (CrossReference)cSignalidAssignment_2_0.eContents().get(0);
		private final RuleCall cSignalidSignalIDIDTerminalRuleCall_2_0_0_1 = (RuleCall)cSignalidSignalIDCrossReference_2_0_0.eContents().get(1);
		private final RuleCall cLSQUAREParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final Assignment cIndx1Assignment_2_2 = (Assignment)cGroup_2.eContents().get(2);
		private final RuleCall cIndx1NumberParserRuleCall_2_2_0 = (RuleCall)cIndx1Assignment_2_2.eContents().get(0);
		private final RuleCall cRSQUAREParserRuleCall_2_3 = (RuleCall)cGroup_2.eContents().get(3);
		private final RuleCall cLSQUAREParserRuleCall_2_4 = (RuleCall)cGroup_2.eContents().get(4);
		private final Assignment cIndx2Assignment_2_5 = (Assignment)cGroup_2.eContents().get(5);
		private final RuleCall cIndx2NumberParserRuleCall_2_5_0 = (RuleCall)cIndx2Assignment_2_5.eContents().get(0);
		private final RuleCall cRSQUAREParserRuleCall_2_6 = (RuleCall)cGroup_2.eContents().get(6);
		private final RuleCall cLPARENParserRuleCall_2_7 = (RuleCall)cGroup_2.eContents().get(7);
		private final Assignment cTimdedtermAssignment_2_8 = (Assignment)cGroup_2.eContents().get(8);
		private final RuleCall cTimdedtermTimedtermParserRuleCall_2_8_0 = (RuleCall)cTimdedtermAssignment_2_8.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_2_9 = (RuleCall)cGroup_2.eContents().get(9);
		
		//Signal:
		//	signalid=[SignalID] LPAREN
		//	timdedterm=timedterm RPAREN | signalid=[SignalID] LSQUARE indx1=number RSQUARE
		//	LPAREN
		//	timdedterm=timedterm RPAREN | signalid=[SignalID] LSQUARE indx1=number RSQUARE LSQUARE indx2=number RSQUARE
		//	LPAREN
		//	timdedterm=timedterm RPAREN;
		@Override public ParserRule getRule() { return rule; }
		
		//signalid=[SignalID] LPAREN timdedterm=timedterm RPAREN | signalid=[SignalID] LSQUARE indx1=number RSQUARE LPAREN
		//timdedterm=timedterm RPAREN | signalid=[SignalID] LSQUARE indx1=number RSQUARE LSQUARE indx2=number RSQUARE LPAREN
		//timdedterm=timedterm RPAREN
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//signalid=[SignalID] LPAREN timdedterm=timedterm RPAREN
		public Group getGroup_0() { return cGroup_0; }
		
		//signalid=[SignalID]
		public Assignment getSignalidAssignment_0_0() { return cSignalidAssignment_0_0; }
		
		//[SignalID]
		public CrossReference getSignalidSignalIDCrossReference_0_0_0() { return cSignalidSignalIDCrossReference_0_0_0; }
		
		//ID
		public RuleCall getSignalidSignalIDIDTerminalRuleCall_0_0_0_1() { return cSignalidSignalIDIDTerminalRuleCall_0_0_0_1; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_0_1() { return cLPARENParserRuleCall_0_1; }
		
		//timdedterm=timedterm
		public Assignment getTimdedtermAssignment_0_2() { return cTimdedtermAssignment_0_2; }
		
		//timedterm
		public RuleCall getTimdedtermTimedtermParserRuleCall_0_2_0() { return cTimdedtermTimedtermParserRuleCall_0_2_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_0_3() { return cRPARENParserRuleCall_0_3; }
		
		//signalid=[SignalID] LSQUARE indx1=number RSQUARE LPAREN timdedterm=timedterm RPAREN
		public Group getGroup_1() { return cGroup_1; }
		
		//signalid=[SignalID]
		public Assignment getSignalidAssignment_1_0() { return cSignalidAssignment_1_0; }
		
		//[SignalID]
		public CrossReference getSignalidSignalIDCrossReference_1_0_0() { return cSignalidSignalIDCrossReference_1_0_0; }
		
		//ID
		public RuleCall getSignalidSignalIDIDTerminalRuleCall_1_0_0_1() { return cSignalidSignalIDIDTerminalRuleCall_1_0_0_1; }
		
		//LSQUARE
		public RuleCall getLSQUAREParserRuleCall_1_1() { return cLSQUAREParserRuleCall_1_1; }
		
		//indx1=number
		public Assignment getIndx1Assignment_1_2() { return cIndx1Assignment_1_2; }
		
		//number
		public RuleCall getIndx1NumberParserRuleCall_1_2_0() { return cIndx1NumberParserRuleCall_1_2_0; }
		
		//RSQUARE
		public RuleCall getRSQUAREParserRuleCall_1_3() { return cRSQUAREParserRuleCall_1_3; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_1_4() { return cLPARENParserRuleCall_1_4; }
		
		//timdedterm=timedterm
		public Assignment getTimdedtermAssignment_1_5() { return cTimdedtermAssignment_1_5; }
		
		//timedterm
		public RuleCall getTimdedtermTimedtermParserRuleCall_1_5_0() { return cTimdedtermTimedtermParserRuleCall_1_5_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_1_6() { return cRPARENParserRuleCall_1_6; }
		
		//signalid=[SignalID] LSQUARE indx1=number RSQUARE LSQUARE indx2=number RSQUARE LPAREN timdedterm=timedterm RPAREN
		public Group getGroup_2() { return cGroup_2; }
		
		//signalid=[SignalID]
		public Assignment getSignalidAssignment_2_0() { return cSignalidAssignment_2_0; }
		
		//[SignalID]
		public CrossReference getSignalidSignalIDCrossReference_2_0_0() { return cSignalidSignalIDCrossReference_2_0_0; }
		
		//ID
		public RuleCall getSignalidSignalIDIDTerminalRuleCall_2_0_0_1() { return cSignalidSignalIDIDTerminalRuleCall_2_0_0_1; }
		
		//LSQUARE
		public RuleCall getLSQUAREParserRuleCall_2_1() { return cLSQUAREParserRuleCall_2_1; }
		
		//indx1=number
		public Assignment getIndx1Assignment_2_2() { return cIndx1Assignment_2_2; }
		
		//number
		public RuleCall getIndx1NumberParserRuleCall_2_2_0() { return cIndx1NumberParserRuleCall_2_2_0; }
		
		//RSQUARE
		public RuleCall getRSQUAREParserRuleCall_2_3() { return cRSQUAREParserRuleCall_2_3; }
		
		//LSQUARE
		public RuleCall getLSQUAREParserRuleCall_2_4() { return cLSQUAREParserRuleCall_2_4; }
		
		//indx2=number
		public Assignment getIndx2Assignment_2_5() { return cIndx2Assignment_2_5; }
		
		//number
		public RuleCall getIndx2NumberParserRuleCall_2_5_0() { return cIndx2NumberParserRuleCall_2_5_0; }
		
		//RSQUARE
		public RuleCall getRSQUAREParserRuleCall_2_6() { return cRSQUAREParserRuleCall_2_6; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_2_7() { return cLPARENParserRuleCall_2_7; }
		
		//timdedterm=timedterm
		public Assignment getTimdedtermAssignment_2_8() { return cTimdedtermAssignment_2_8; }
		
		//timedterm
		public RuleCall getTimdedtermTimedtermParserRuleCall_2_8_0() { return cTimdedtermTimedtermParserRuleCall_2_8_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_2_9() { return cRPARENParserRuleCall_2_9; }
	}
	public class AbsEXPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.AbsEXP");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExp1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExp1ExpressionParserRuleCall_1_0 = (RuleCall)cExp1Assignment_1.eContents().get(0);
		private final Keyword cVerticalLineKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//AbsEXP:
		//	'|' exp1=expression '|';
		@Override public ParserRule getRule() { return rule; }
		
		//'|' exp1=expression '|'
		public Group getGroup() { return cGroup; }
		
		//'|'
		public Keyword getVerticalLineKeyword_0() { return cVerticalLineKeyword_0; }
		
		//exp1=expression
		public Assignment getExp1Assignment_1() { return cExp1Assignment_1; }
		
		//expression
		public RuleCall getExp1ExpressionParserRuleCall_1_0() { return cExp1ExpressionParserRuleCall_1_0; }
		
		//'|'
		public Keyword getVerticalLineKeyword_2() { return cVerticalLineKeyword_2; }
	}
	public class NormexpElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Normexp");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cVerticalLineVerticalLineKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cExp1Assignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cExp1ExpressionParserRuleCall_1_0 = (RuleCall)cExp1Assignment_1.eContents().get(0);
		private final Keyword cVerticalLineVerticalLineKeyword_2 = (Keyword)cGroup.eContents().get(2);
		
		//Normexp:
		//	'||' exp1=expression '||';
		@Override public ParserRule getRule() { return rule; }
		
		//'||' exp1=expression '||'
		public Group getGroup() { return cGroup; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_0() { return cVerticalLineVerticalLineKeyword_0; }
		
		//exp1=expression
		public Assignment getExp1Assignment_1() { return cExp1Assignment_1; }
		
		//expression
		public RuleCall getExp1ExpressionParserRuleCall_1_0() { return cExp1ExpressionParserRuleCall_1_0; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword_2() { return cVerticalLineVerticalLineKeyword_2; }
	}
	public class SinElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Sin");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSinKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cLPARENParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cExp1Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExp1ExpressionParserRuleCall_2_0 = (RuleCall)cExp1Assignment_2.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//Sin:
		//	'sin' LPAREN exp1=expression RPAREN;
		@Override public ParserRule getRule() { return rule; }
		
		//'sin' LPAREN exp1=expression RPAREN
		public Group getGroup() { return cGroup; }
		
		//'sin'
		public Keyword getSinKeyword_0() { return cSinKeyword_0; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_1() { return cLPARENParserRuleCall_1; }
		
		//exp1=expression
		public Assignment getExp1Assignment_2() { return cExp1Assignment_2; }
		
		//expression
		public RuleCall getExp1ExpressionParserRuleCall_2_0() { return cExp1ExpressionParserRuleCall_2_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_3() { return cRPARENParserRuleCall_3; }
	}
	public class CosElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Cos");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cCosKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cLPARENParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cExp1Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExp1ExpressionParserRuleCall_2_0 = (RuleCall)cExp1Assignment_2.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//Cos:
		//	'cos' LPAREN exp1=expression RPAREN;
		@Override public ParserRule getRule() { return rule; }
		
		//'cos' LPAREN exp1=expression RPAREN
		public Group getGroup() { return cGroup; }
		
		//'cos'
		public Keyword getCosKeyword_0() { return cCosKeyword_0; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_1() { return cLPARENParserRuleCall_1; }
		
		//exp1=expression
		public Assignment getExp1Assignment_2() { return cExp1Assignment_2; }
		
		//expression
		public RuleCall getExp1ExpressionParserRuleCall_2_0() { return cExp1ExpressionParserRuleCall_2_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_3() { return cRPARENParserRuleCall_3; }
	}
	public class SqrtElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.Sqrt");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSqrtKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final RuleCall cLPARENParserRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cExp1Assignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cExp1ExpressionParserRuleCall_2_0 = (RuleCall)cExp1Assignment_2.eContents().get(0);
		private final RuleCall cRPARENParserRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		//Sqrt:
		//	'sqrt' LPAREN exp1=expression RPAREN;
		@Override public ParserRule getRule() { return rule; }
		
		//'sqrt' LPAREN exp1=expression RPAREN
		public Group getGroup() { return cGroup; }
		
		//'sqrt'
		public Keyword getSqrtKeyword_0() { return cSqrtKeyword_0; }
		
		//LPAREN
		public RuleCall getLPARENParserRuleCall_1() { return cLPARENParserRuleCall_1; }
		
		//exp1=expression
		public Assignment getExp1Assignment_2() { return cExp1Assignment_2; }
		
		//expression
		public RuleCall getExp1ExpressionParserRuleCall_2_0() { return cExp1ExpressionParserRuleCall_2_0; }
		
		//RPAREN
		public RuleCall getRPARENParserRuleCall_3() { return cRPARENParserRuleCall_3; }
	}
	public class Bin_connectiveElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.bin_connective");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCONJParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDISJParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cIMPLParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cBICONDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//bin_connective:
		//	CONJ | DISJ | IMPL | BICOND;
		@Override public ParserRule getRule() { return rule; }
		
		//CONJ | DISJ | IMPL | BICOND
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CONJ
		public RuleCall getCONJParserRuleCall_0() { return cCONJParserRuleCall_0; }
		
		//DISJ
		public RuleCall getDISJParserRuleCall_1() { return cDISJParserRuleCall_1; }
		
		//IMPL
		public RuleCall getIMPLParserRuleCall_2() { return cIMPLParserRuleCall_2; }
		
		//BICOND
		public RuleCall getBICONDParserRuleCall_3() { return cBICONDParserRuleCall_3; }
	}
	public class FLOATElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.FLOAT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cNumberParserRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cNumberParserRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//FLOAT:
		//	number '.' number;
		@Override public ParserRule getRule() { return rule; }
		
		//number '.' number
		public Group getGroup() { return cGroup; }
		
		//number
		public RuleCall getNumberParserRuleCall_0() { return cNumberParserRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//number
		public RuleCall getNumberParserRuleCall_2() { return cNumberParserRuleCall_2; }
	}
	public class PATHElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.PATH");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Alternatives cAlternatives_0 = (Alternatives)cGroup.eContents().get(0);
		private final Keyword cFullStopFullStopSolidusKeyword_0_0 = (Keyword)cAlternatives_0.eContents().get(0);
		private final Keyword cFullStopSolidusKeyword_0_1 = (Keyword)cAlternatives_0.eContents().get(1);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cIDTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Keyword cSolidusKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		
		//PATH:
		//	('../'* | './') (ID '/')*;
		@Override public ParserRule getRule() { return rule; }
		
		//('../'* | './') (ID '/')*
		public Group getGroup() { return cGroup; }
		
		//('../'* | './')
		public Alternatives getAlternatives_0() { return cAlternatives_0; }
		
		//'../'*
		public Keyword getFullStopFullStopSolidusKeyword_0_0() { return cFullStopFullStopSolidusKeyword_0_0; }
		
		//'./'
		public Keyword getFullStopSolidusKeyword_0_1() { return cFullStopSolidusKeyword_0_1; }
		
		//(ID '/')*
		public Group getGroup_1() { return cGroup_1; }
		
		//ID
		public RuleCall getIDTerminalRuleCall_1_0() { return cIDTerminalRuleCall_1_0; }
		
		//'/'
		public Keyword getSolidusKeyword_1_1() { return cSolidusKeyword_1_1; }
	}
	public class NumberElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.number");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDIGITTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//number:
		//	INT | DIGIT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT | DIGIT
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//DIGIT
		public RuleCall getDIGITTerminalRuleCall_1() { return cDIGITTerminalRuleCall_1; }
	}
	public class RELOPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.RELOP");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cGEParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cLEParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEQParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLEQParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cGEQParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cNEQParserRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		//RELOP:
		//	GE | LE | EQ | LEQ | GEQ | NEQ;
		@Override public ParserRule getRule() { return rule; }
		
		//GE | LE | EQ | LEQ | GEQ | NEQ
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//GE
		public RuleCall getGEParserRuleCall_0() { return cGEParserRuleCall_0; }
		
		//LE
		public RuleCall getLEParserRuleCall_1() { return cLEParserRuleCall_1; }
		
		//EQ
		public RuleCall getEQParserRuleCall_2() { return cEQParserRuleCall_2; }
		
		//LEQ
		public RuleCall getLEQParserRuleCall_3() { return cLEQParserRuleCall_3; }
		
		//GEQ
		public RuleCall getGEQParserRuleCall_4() { return cGEQParserRuleCall_4; }
		
		//NEQ
		public RuleCall getNEQParserRuleCall_5() { return cNEQParserRuleCall_5; }
	}
	public class COMMAElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.COMMA");
		private final Keyword cCommaKeyword = (Keyword)rule.eContents().get(1);
		
		//COMMA:
		//	',';
		@Override public ParserRule getRule() { return rule; }
		
		//','
		public Keyword getCommaKeyword() { return cCommaKeyword; }
	}
	public class LEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.LE");
		private final Keyword cLessThanSignKeyword = (Keyword)rule.eContents().get(1);
		
		//LE:
		//	'<';
		@Override public ParserRule getRule() { return rule; }
		
		//'<'
		public Keyword getLessThanSignKeyword() { return cLessThanSignKeyword; }
	}
	public class LEQElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.LEQ");
		private final Keyword cLessThanSignEqualsSignKeyword = (Keyword)rule.eContents().get(1);
		
		//LEQ:
		//	'<=';
		@Override public ParserRule getRule() { return rule; }
		
		//'<='
		public Keyword getLessThanSignEqualsSignKeyword() { return cLessThanSignEqualsSignKeyword; }
	}
	public class GEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.GE");
		private final Keyword cGreaterThanSignKeyword = (Keyword)rule.eContents().get(1);
		
		//GE:
		//	'>';
		@Override public ParserRule getRule() { return rule; }
		
		//'>'
		public Keyword getGreaterThanSignKeyword() { return cGreaterThanSignKeyword; }
	}
	public class GEQElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.GEQ");
		private final Keyword cGreaterThanSignEqualsSignKeyword = (Keyword)rule.eContents().get(1);
		
		//GEQ:
		//	'>=';
		@Override public ParserRule getRule() { return rule; }
		
		//'>='
		public Keyword getGreaterThanSignEqualsSignKeyword() { return cGreaterThanSignEqualsSignKeyword; }
	}
	public class EQElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.EQ");
		private final Keyword cEqualsSignKeyword = (Keyword)rule.eContents().get(1);
		
		//EQ:
		//	'=';
		@Override public ParserRule getRule() { return rule; }
		
		//'='
		public Keyword getEqualsSignKeyword() { return cEqualsSignKeyword; }
	}
	public class NEQElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.NEQ");
		private final Keyword cExclamationMarkEqualsSignKeyword = (Keyword)rule.eContents().get(1);
		
		//NEQ:
		//	'!=';
		@Override public ParserRule getRule() { return rule; }
		
		//'!='
		public Keyword getExclamationMarkEqualsSignKeyword() { return cExclamationMarkEqualsSignKeyword; }
	}
	public class LPARENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.LPAREN");
		private final Keyword cLeftParenthesisKeyword = (Keyword)rule.eContents().get(1);
		
		//LPAREN:
		//	'(';
		@Override public ParserRule getRule() { return rule; }
		
		//'('
		public Keyword getLeftParenthesisKeyword() { return cLeftParenthesisKeyword; }
	}
	public class RPARENElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.RPAREN");
		private final Keyword cRightParenthesisKeyword = (Keyword)rule.eContents().get(1);
		
		//RPAREN:
		//	')';
		@Override public ParserRule getRule() { return rule; }
		
		//')'
		public Keyword getRightParenthesisKeyword() { return cRightParenthesisKeyword; }
	}
	public class LSQUAREElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.LSQUARE");
		private final Keyword cLeftSquareBracketKeyword = (Keyword)rule.eContents().get(1);
		
		//LSQUARE:
		//	'[';
		@Override public ParserRule getRule() { return rule; }
		
		//'['
		public Keyword getLeftSquareBracketKeyword() { return cLeftSquareBracketKeyword; }
	}
	public class RSQUAREElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.RSQUARE");
		private final Keyword cRightSquareBracketKeyword = (Keyword)rule.eContents().get(1);
		
		//RSQUARE:
		//	']';
		@Override public ParserRule getRule() { return rule; }
		
		//']'
		public Keyword getRightSquareBracketKeyword() { return cRightSquareBracketKeyword; }
	}
	public class NOTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.NOT");
		private final Keyword cNotKeyword = (Keyword)rule.eContents().get(1);
		
		//NOT:
		//	'not';
		@Override public ParserRule getRule() { return rule; }
		
		//'not'
		public Keyword getNotKeyword() { return cNotKeyword; }
	}
	public class FORALLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.FORALL");
		private final Keyword cForallKeyword = (Keyword)rule.eContents().get(1);
		
		//FORALL:
		//	'forall';
		@Override public ParserRule getRule() { return rule; }
		
		//'forall'
		public Keyword getForallKeyword() { return cForallKeyword; }
	}
	public class EXISTSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.EXISTS");
		private final Keyword cExistsKeyword = (Keyword)rule.eContents().get(1);
		
		//EXISTS:
		//	'exists';
		@Override public ParserRule getRule() { return rule; }
		
		//'exists'
		public Keyword getExistsKeyword() { return cExistsKeyword; }
	}
	public class CONJElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.CONJ");
		private final Keyword cAndKeyword = (Keyword)rule.eContents().get(1);
		
		//CONJ:
		//	'and';
		@Override public ParserRule getRule() { return rule; }
		
		//'and'
		public Keyword getAndKeyword() { return cAndKeyword; }
	}
	public class DISJElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.DISJ");
		private final Keyword cOrKeyword = (Keyword)rule.eContents().get(1);
		
		//DISJ:
		//	'or';
		@Override public ParserRule getRule() { return rule; }
		
		//'or'
		public Keyword getOrKeyword() { return cOrKeyword; }
	}
	public class IMPLElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.IMPL");
		private final Keyword cImpliesKeyword = (Keyword)rule.eContents().get(1);
		
		//IMPL:
		//	'implies';
		@Override public ParserRule getRule() { return rule; }
		
		//'implies'
		public Keyword getImpliesKeyword() { return cImpliesKeyword; }
	}
	public class BICONDElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.BICOND");
		private final Keyword cIffKeyword = (Keyword)rule.eContents().get(1);
		
		//BICOND:
		//	'iff';
		@Override public ParserRule getRule() { return rule; }
		
		//'iff'
		public Keyword getIffKeyword() { return cIffKeyword; }
	}
	public class INFElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.INF");
		private final Keyword cInfKeyword = (Keyword)rule.eContents().get(1);
		
		//INF:
		//	'inf';
		@Override public ParserRule getRule() { return rule; }
		
		//'inf'
		public Keyword getInfKeyword() { return cInfKeyword; }
	}
	public class INElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.IN");
		private final Keyword cInKeyword = (Keyword)rule.eContents().get(1);
		
		//IN:
		//	'in';
		@Override public ParserRule getRule() { return rule; }
		
		//'in'
		public Keyword getInKeyword() { return cInKeyword; }
	}
	public class NORMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.NORM");
		private final Keyword cVerticalLineVerticalLineKeyword = (Keyword)rule.eContents().get(1);
		
		//NORM:
		//	'||';
		@Override public ParserRule getRule() { return rule; }
		
		//'||'
		public Keyword getVerticalLineVerticalLineKeyword() { return cVerticalLineVerticalLineKeyword; }
	}
	public class PLUSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.PLUS");
		private final Keyword cPlusSignKeyword = (Keyword)rule.eContents().get(1);
		
		//PLUS:
		//	'+';
		@Override public ParserRule getRule() { return rule; }
		
		//'+'
		public Keyword getPlusSignKeyword() { return cPlusSignKeyword; }
	}
	public class MINUSElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.MINUS");
		private final Keyword cHyphenMinusKeyword = (Keyword)rule.eContents().get(1);
		
		//MINUS:
		//	'-';
		@Override public ParserRule getRule() { return rule; }
		
		//'-'
		public Keyword getHyphenMinusKeyword() { return cHyphenMinusKeyword; }
	}
	public class COLONElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.COLON");
		private final Keyword cColonKeyword = (Keyword)rule.eContents().get(1);
		
		//COLON:
		//	':';
		@Override public ParserRule getRule() { return rule; }
		
		//':'
		public Keyword getColonKeyword() { return cColonKeyword; }
	}
	public class SIGNElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.SIGN");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cPLUSParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cMINUSParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//SIGN:
		//	PLUS | MINUS;
		@Override public ParserRule getRule() { return rule; }
		
		//PLUS | MINUS
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//PLUS
		public RuleCall getPLUSParserRuleCall_0() { return cPLUSParserRuleCall_0; }
		
		//MINUS
		public RuleCall getMINUSParserRuleCall_1() { return cMINUSParserRuleCall_1; }
	}
	public class OPElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.OP");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Keyword cPlusSignKeyword_0 = (Keyword)cAlternatives.eContents().get(0);
		private final Keyword cHyphenMinusKeyword_1 = (Keyword)cAlternatives.eContents().get(1);
		private final Keyword cAsteriskKeyword_2 = (Keyword)cAlternatives.eContents().get(2);
		private final Keyword cSolidusKeyword_3 = (Keyword)cAlternatives.eContents().get(3);
		
		//OP:
		//	'+' | '-' | '*' | '/';
		@Override public ParserRule getRule() { return rule; }
		
		//'+' | '-' | '*' | '/'
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//'+'
		public Keyword getPlusSignKeyword_0() { return cPlusSignKeyword_0; }
		
		//'-'
		public Keyword getHyphenMinusKeyword_1() { return cHyphenMinusKeyword_1; }
		
		//'*'
		public Keyword getAsteriskKeyword_2() { return cAsteriskKeyword_2; }
		
		//'/'
		public Keyword getSolidusKeyword_3() { return cSolidusKeyword_3; }
	}
	
	
	private final SocratesElements pSocrates;
	private final OracleElements pOracle;
	private final RequirementElements pRequirement;
	private final ReqIdElements pReqId;
	private final TerminalRule tDESCRIPTION;
	private final SignalsdefinitionElements pSignalsdefinition;
	private final ConstantsDefinitionElements pConstantsDefinition;
	private final ConstantDefinitionElements pConstantDefinition;
	private final SignalIDElements pSignalID;
	private final ConstantIdElements pConstantId;
	private final ForAllformulaElements pForAllformula;
	private final ExistsformulaElements pExistsformula;
	private final TvariableElements pTvariable;
	private final NegationformulaElements pNegationformula;
	private final FormulaElements pFormula;
	private final FormulabElements pFormulab;
	private final FormulabprimeElements pFormulabprime;
	private final TermElements pTerm;
	private final TermprimeElements pTermprime;
	private final ExpressionElements pExpression;
	private final ExpressionbElements pExpressionb;
	private final ExpressionprimeElements pExpressionprime;
	private final ExpressiontermElements pExpressionterm;
	private final ExpressiontermprimeElements pExpressiontermprime;
	private final ExpressionAtomElements pExpressionAtom;
	private final BasicexpressionElements pBasicexpression;
	private final BasicformulaeElements pBasicformulae;
	private final BoundtermElements pBoundterm;
	private final TimedtermElements pTimedterm;
	private final AtomElements pAtom;
	private final ValueElements pValue;
	private final SignalElements pSignal;
	private final AbsEXPElements pAbsEXP;
	private final NormexpElements pNormexp;
	private final SinElements pSin;
	private final CosElements pCos;
	private final SqrtElements pSqrt;
	private final Bin_connectiveElements pBin_connective;
	private final FLOATElements pFLOAT;
	private final PATHElements pPATH;
	private final NumberElements pNumber;
	private final TerminalRule tWS;
	private final RELOPElements pRELOP;
	private final COMMAElements pCOMMA;
	private final LEElements pLE;
	private final LEQElements pLEQ;
	private final GEElements pGE;
	private final GEQElements pGEQ;
	private final EQElements pEQ;
	private final NEQElements pNEQ;
	private final LPARENElements pLPAREN;
	private final RPARENElements pRPAREN;
	private final LSQUAREElements pLSQUARE;
	private final RSQUAREElements pRSQUARE;
	private final NOTElements pNOT;
	private final FORALLElements pFORALL;
	private final EXISTSElements pEXISTS;
	private final CONJElements pCONJ;
	private final DISJElements pDISJ;
	private final IMPLElements pIMPL;
	private final BICONDElements pBICOND;
	private final INFElements pINF;
	private final INElements pIN;
	private final NORMElements pNORM;
	private final PLUSElements pPLUS;
	private final MINUSElements pMINUS;
	private final COLONElements pCOLON;
	private final SIGNElements pSIGN;
	private final OPElements pOP;
	private final TerminalRule tML_COMMENT;
	private final TerminalRule tDIGIT;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public SocratesGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pSocrates = new SocratesElements();
		this.pOracle = new OracleElements();
		this.pRequirement = new RequirementElements();
		this.pReqId = new ReqIdElements();
		this.tDESCRIPTION = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.DESCRIPTION");
		this.pSignalsdefinition = new SignalsdefinitionElements();
		this.pConstantsDefinition = new ConstantsDefinitionElements();
		this.pConstantDefinition = new ConstantDefinitionElements();
		this.pSignalID = new SignalIDElements();
		this.pConstantId = new ConstantIdElements();
		this.pForAllformula = new ForAllformulaElements();
		this.pExistsformula = new ExistsformulaElements();
		this.pTvariable = new TvariableElements();
		this.pNegationformula = new NegationformulaElements();
		this.pFormula = new FormulaElements();
		this.pFormulab = new FormulabElements();
		this.pFormulabprime = new FormulabprimeElements();
		this.pTerm = new TermElements();
		this.pTermprime = new TermprimeElements();
		this.pExpression = new ExpressionElements();
		this.pExpressionb = new ExpressionbElements();
		this.pExpressionprime = new ExpressionprimeElements();
		this.pExpressionterm = new ExpressiontermElements();
		this.pExpressiontermprime = new ExpressiontermprimeElements();
		this.pExpressionAtom = new ExpressionAtomElements();
		this.pBasicexpression = new BasicexpressionElements();
		this.pBasicformulae = new BasicformulaeElements();
		this.pBoundterm = new BoundtermElements();
		this.pTimedterm = new TimedtermElements();
		this.pAtom = new AtomElements();
		this.pValue = new ValueElements();
		this.pSignal = new SignalElements();
		this.pAbsEXP = new AbsEXPElements();
		this.pNormexp = new NormexpElements();
		this.pSin = new SinElements();
		this.pCos = new CosElements();
		this.pSqrt = new SqrtElements();
		this.pBin_connective = new Bin_connectiveElements();
		this.pFLOAT = new FLOATElements();
		this.pPATH = new PATHElements();
		this.pNumber = new NumberElements();
		this.tWS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.WS");
		this.pRELOP = new RELOPElements();
		this.pCOMMA = new COMMAElements();
		this.pLE = new LEElements();
		this.pLEQ = new LEQElements();
		this.pGE = new GEElements();
		this.pGEQ = new GEQElements();
		this.pEQ = new EQElements();
		this.pNEQ = new NEQElements();
		this.pLPAREN = new LPARENElements();
		this.pRPAREN = new RPARENElements();
		this.pLSQUARE = new LSQUAREElements();
		this.pRSQUARE = new RSQUAREElements();
		this.pNOT = new NOTElements();
		this.pFORALL = new FORALLElements();
		this.pEXISTS = new EXISTSElements();
		this.pCONJ = new CONJElements();
		this.pDISJ = new DISJElements();
		this.pIMPL = new IMPLElements();
		this.pBICOND = new BICONDElements();
		this.pINF = new INFElements();
		this.pIN = new INElements();
		this.pNORM = new NORMElements();
		this.pPLUS = new PLUSElements();
		this.pMINUS = new MINUSElements();
		this.pCOLON = new COLONElements();
		this.pSIGN = new SIGNElements();
		this.pOP = new OPElements();
		this.tML_COMMENT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.ML_COMMENT");
		this.tDIGIT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "lu.uni.Socrates.DIGIT");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("lu.uni.Socrates".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//// Socrates: generating Simulink Oracles for CPS RequiremenTs with uncErtainty
	//Socrates:
	//	oracles+=Oracle*;
	public SocratesElements getSocratesAccess() {
		return pSocrates;
	}
	
	public ParserRule getSocratesRule() {
		return getSocratesAccess().getRule();
	}
	
	//Oracle:
	//	'Oracle'
	//	'ModelName:' modelName=ID ';' ('Path:' path=PATH ';')?
	//	'ID:' reqname=ReqId ';'
	//	signdef=Signalsdefinition
	//	constantDefinitions=ConstantsDefinition?
	//	requirement=Requirement;
	public OracleElements getOracleAccess() {
		return pOracle;
	}
	
	public ParserRule getOracleRule() {
		return getOracleAccess().getRule();
	}
	
	//Requirement:
	//	'Description:' DESCRIPTION ';'
	//	'Specification:' formula=formula ';';
	public RequirementElements getRequirementAccess() {
		return pRequirement;
	}
	
	public ParserRule getRequirementRule() {
		return getRequirementAccess().getRule();
	}
	
	//ReqId:
	//	ID ('_' number ('_' number)*)?;
	public ReqIdElements getReqIdAccess() {
		return pReqId;
	}
	
	public ParserRule getReqIdRule() {
		return getReqIdAccess().getRule();
	}
	
	//terminal DESCRIPTION:
	//	'"'->'"';
	public TerminalRule getDESCRIPTIONRule() {
		return tDESCRIPTION;
	}
	
	//Signalsdefinition:
	//	'Signals' signals+=SignalID (',' signals+=SignalID)* ';';
	public SignalsdefinitionElements getSignalsdefinitionAccess() {
		return pSignalsdefinition;
	}
	
	public ParserRule getSignalsdefinitionRule() {
		return getSignalsdefinitionAccess().getRule();
	}
	
	//ConstantsDefinition:
	//	'Constants' constants+=ConstantDefinition (',' constants+=ConstantDefinition)* ';';
	public ConstantsDefinitionElements getConstantsDefinitionAccess() {
		return pConstantsDefinition;
	}
	
	public ParserRule getConstantsDefinitionRule() {
		return getConstantsDefinitionAccess().getRule();
	}
	
	//ConstantDefinition:
	//	constantid=ConstantId EQ SIGN? value=number;
	public ConstantDefinitionElements getConstantDefinitionAccess() {
		return pConstantDefinition;
	}
	
	public ParserRule getConstantDefinitionRule() {
		return getConstantDefinitionAccess().getRule();
	}
	
	//SignalID:
	//	name=ID;
	public SignalIDElements getSignalIDAccess() {
		return pSignalID;
	}
	
	public ParserRule getSignalIDRule() {
		return getSignalIDAccess().getRule();
	}
	
	//ConstantId:
	//	name=ID;
	public ConstantIdElements getConstantIdAccess() {
		return pConstantId;
	}
	
	public ParserRule getConstantIdRule() {
		return getConstantIdAccess().getRule();
	}
	
	//ForAllformula:
	//	FORALL bound=boundterm COLON LPAREN forallchild=formula RPAREN;
	public ForAllformulaElements getForAllformulaAccess() {
		return pForAllformula;
	}
	
	public ParserRule getForAllformulaRule() {
		return getForAllformulaAccess().getRule();
	}
	
	//Existsformula:
	//	EXISTS bound=boundterm COLON LPAREN existschild=formula RPAREN;
	public ExistsformulaElements getExistsformulaAccess() {
		return pExistsformula;
	}
	
	public ParserRule getExistsformulaRule() {
		return getExistsformulaAccess().getRule();
	}
	
	//Tvariable:
	//	name=ID;
	public TvariableElements getTvariableAccess() {
		return pTvariable;
	}
	
	public ParserRule getTvariableRule() {
		return getTvariableAccess().getRule();
	}
	
	//negationformula:
	//	NOT negationchild=formula;
	public NegationformulaElements getNegationformulaAccess() {
		return pNegationformula;
	}
	
	public ParserRule getNegationformulaRule() {
		return getNegationformulaAccess().getRule();
	}
	
	//formula:
	//	f=basicformulae | f=formulab;
	public FormulaElements getFormulaAccess() {
		return pFormula;
	}
	
	public ParserRule getFormulaRule() {
		return getFormulaAccess().getRule();
	}
	
	//formulab:
	//	a=term t=formulabprime;
	public FormulabElements getFormulabAccess() {
		return pFormulab;
	}
	
	public ParserRule getFormulabRule() {
		return getFormulabAccess().getRule();
	}
	
	//formulabprime:
	//	(op=('or' | 'implies' | 'iff') t2=term f=formulabprime)?;
	public FormulabprimeElements getFormulabprimeAccess() {
		return pFormulabprime;
	}
	
	public ParserRule getFormulabprimeRule() {
		return getFormulabprimeAccess().getRule();
	}
	
	//term:
	//	a=atom t=termprime;
	public TermElements getTermAccess() {
		return pTerm;
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//termprime:
	//	(op='and' t=term f1=termprime)?;
	public TermprimeElements getTermprimeAccess() {
		return pTermprime;
	}
	
	public ParserRule getTermprimeRule() {
		return getTermprimeAccess().getRule();
	}
	
	//expression:
	//	expb=expressionb;
	public ExpressionElements getExpressionAccess() {
		return pExpression;
	}
	
	public ParserRule getExpressionRule() {
		return getExpressionAccess().getRule();
	}
	
	//expressionb:
	//	term=expressionterm expprime=expressionprime | LPAREN term=expressionterm RPAREN expprime=expressionprime;
	public ExpressionbElements getExpressionbAccess() {
		return pExpressionb;
	}
	
	public ParserRule getExpressionbRule() {
		return getExpressionbAccess().getRule();
	}
	
	//expressionprime:
	//	(op=('+' | '-') t2=expressionterm f=expressionprime)?;
	public ExpressionprimeElements getExpressionprimeAccess() {
		return pExpressionprime;
	}
	
	public ParserRule getExpressionprimeRule() {
		return getExpressionprimeAccess().getRule();
	}
	
	//expressionterm:
	//	term=(ExpressionAtom | Basicexpression) expprime=expressiontermprime;
	public ExpressiontermElements getExpressiontermAccess() {
		return pExpressionterm;
	}
	
	public ParserRule getExpressiontermRule() {
		return getExpressiontermAccess().getRule();
	}
	
	//expressiontermprime:
	//	(op=('*' | '/') t2=expressionterm f=expressiontermprime)?;
	public ExpressiontermprimeElements getExpressiontermprimeAccess() {
		return pExpressiontermprime;
	}
	
	public ParserRule getExpressiontermprimeRule() {
		return getExpressiontermprimeAccess().getRule();
	}
	
	//ExpressionAtom:
	//	exp=Signal | LPAREN exp=expression RPAREN | op=SIGN exp=expression | exp=value;
	public ExpressionAtomElements getExpressionAtomAccess() {
		return pExpressionAtom;
	}
	
	public ParserRule getExpressionAtomRule() {
		return getExpressionAtomAccess().getRule();
	}
	
	//Basicexpression:
	//	LPAREN exp=Basicexpression RPAREN | exp=AbsEXP | exp=Normexp | exp=Sin | exp=Cos | exp=Sqrt;
	public BasicexpressionElements getBasicexpressionAccess() {
		return pBasicexpression;
	}
	
	public ParserRule getBasicexpressionRule() {
		return getBasicexpressionAccess().getRule();
	}
	
	//basicformulae:
	//	f=negationformula
	//	| f=ForAllformula
	//	| f=Existsformula;
	public BasicformulaeElements getBasicformulaeAccess() {
		return pBasicformulae;
	}
	
	public ParserRule getBasicformulaeRule() {
		return getBasicformulaeAccess().getRule();
	}
	
	//boundterm:
	//	ref=Tvariable IN (l=LSQUARE | l=LPAREN) leftbound=timedterm COMMA rightbound=timedterm (r=RSQUARE | r=RPAREN);
	public BoundtermElements getBoundtermAccess() {
		return pBoundterm;
	}
	
	public ParserRule getBoundtermRule() {
		return getBoundtermAccess().getRule();
	}
	
	//timedterm:
	//	inf=INF
	//	| number=number
	//	| (ref=[ConstantId] | ref=[Tvariable]) (op=(PLUS | MINUS) value=value)?;
	public TimedtermElements getTimedtermAccess() {
		return pTimedterm;
	}
	
	public ParserRule getTimedtermRule() {
		return getTimedtermAccess().getRule();
	}
	
	//atom:
	//	LPAREN f=formula RPAREN |
	//	'{' s1=expression op=RELOP s2=expression "}";
	public AtomElements getAtomAccess() {
		return pAtom;
	}
	
	public ParserRule getAtomRule() {
		return getAtomAccess().getRule();
	}
	
	//value:
	//	LPAREN exp=expression RPAREN | number=number
	//	| ref=[ConstantId] | float=FLOAT;
	public ValueElements getValueAccess() {
		return pValue;
	}
	
	public ParserRule getValueRule() {
		return getValueAccess().getRule();
	}
	
	//Signal:
	//	signalid=[SignalID] LPAREN
	//	timdedterm=timedterm RPAREN | signalid=[SignalID] LSQUARE indx1=number RSQUARE
	//	LPAREN
	//	timdedterm=timedterm RPAREN | signalid=[SignalID] LSQUARE indx1=number RSQUARE LSQUARE indx2=number RSQUARE
	//	LPAREN
	//	timdedterm=timedterm RPAREN;
	public SignalElements getSignalAccess() {
		return pSignal;
	}
	
	public ParserRule getSignalRule() {
		return getSignalAccess().getRule();
	}
	
	//AbsEXP:
	//	'|' exp1=expression '|';
	public AbsEXPElements getAbsEXPAccess() {
		return pAbsEXP;
	}
	
	public ParserRule getAbsEXPRule() {
		return getAbsEXPAccess().getRule();
	}
	
	//Normexp:
	//	'||' exp1=expression '||';
	public NormexpElements getNormexpAccess() {
		return pNormexp;
	}
	
	public ParserRule getNormexpRule() {
		return getNormexpAccess().getRule();
	}
	
	//Sin:
	//	'sin' LPAREN exp1=expression RPAREN;
	public SinElements getSinAccess() {
		return pSin;
	}
	
	public ParserRule getSinRule() {
		return getSinAccess().getRule();
	}
	
	//Cos:
	//	'cos' LPAREN exp1=expression RPAREN;
	public CosElements getCosAccess() {
		return pCos;
	}
	
	public ParserRule getCosRule() {
		return getCosAccess().getRule();
	}
	
	//Sqrt:
	//	'sqrt' LPAREN exp1=expression RPAREN;
	public SqrtElements getSqrtAccess() {
		return pSqrt;
	}
	
	public ParserRule getSqrtRule() {
		return getSqrtAccess().getRule();
	}
	
	//bin_connective:
	//	CONJ | DISJ | IMPL | BICOND;
	public Bin_connectiveElements getBin_connectiveAccess() {
		return pBin_connective;
	}
	
	public ParserRule getBin_connectiveRule() {
		return getBin_connectiveAccess().getRule();
	}
	
	//FLOAT:
	//	number '.' number;
	public FLOATElements getFLOATAccess() {
		return pFLOAT;
	}
	
	public ParserRule getFLOATRule() {
		return getFLOATAccess().getRule();
	}
	
	//PATH:
	//	('../'* | './') (ID '/')*;
	public PATHElements getPATHAccess() {
		return pPATH;
	}
	
	public ParserRule getPATHRule() {
		return getPATHAccess().getRule();
	}
	
	//number:
	//	INT | DIGIT;
	public NumberElements getNumberAccess() {
		return pNumber;
	}
	
	public ParserRule getNumberRule() {
		return getNumberAccess().getRule();
	}
	
	//@Override
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n';
	public TerminalRule getWSRule() {
		return tWS;
	}
	
	//RELOP:
	//	GE | LE | EQ | LEQ | GEQ | NEQ;
	public RELOPElements getRELOPAccess() {
		return pRELOP;
	}
	
	public ParserRule getRELOPRule() {
		return getRELOPAccess().getRule();
	}
	
	//COMMA:
	//	',';
	public COMMAElements getCOMMAAccess() {
		return pCOMMA;
	}
	
	public ParserRule getCOMMARule() {
		return getCOMMAAccess().getRule();
	}
	
	//LE:
	//	'<';
	public LEElements getLEAccess() {
		return pLE;
	}
	
	public ParserRule getLERule() {
		return getLEAccess().getRule();
	}
	
	//LEQ:
	//	'<=';
	public LEQElements getLEQAccess() {
		return pLEQ;
	}
	
	public ParserRule getLEQRule() {
		return getLEQAccess().getRule();
	}
	
	//GE:
	//	'>';
	public GEElements getGEAccess() {
		return pGE;
	}
	
	public ParserRule getGERule() {
		return getGEAccess().getRule();
	}
	
	//GEQ:
	//	'>=';
	public GEQElements getGEQAccess() {
		return pGEQ;
	}
	
	public ParserRule getGEQRule() {
		return getGEQAccess().getRule();
	}
	
	//EQ:
	//	'=';
	public EQElements getEQAccess() {
		return pEQ;
	}
	
	public ParserRule getEQRule() {
		return getEQAccess().getRule();
	}
	
	//NEQ:
	//	'!=';
	public NEQElements getNEQAccess() {
		return pNEQ;
	}
	
	public ParserRule getNEQRule() {
		return getNEQAccess().getRule();
	}
	
	//LPAREN:
	//	'(';
	public LPARENElements getLPARENAccess() {
		return pLPAREN;
	}
	
	public ParserRule getLPARENRule() {
		return getLPARENAccess().getRule();
	}
	
	//RPAREN:
	//	')';
	public RPARENElements getRPARENAccess() {
		return pRPAREN;
	}
	
	public ParserRule getRPARENRule() {
		return getRPARENAccess().getRule();
	}
	
	//LSQUARE:
	//	'[';
	public LSQUAREElements getLSQUAREAccess() {
		return pLSQUARE;
	}
	
	public ParserRule getLSQUARERule() {
		return getLSQUAREAccess().getRule();
	}
	
	//RSQUARE:
	//	']';
	public RSQUAREElements getRSQUAREAccess() {
		return pRSQUARE;
	}
	
	public ParserRule getRSQUARERule() {
		return getRSQUAREAccess().getRule();
	}
	
	//NOT:
	//	'not';
	public NOTElements getNOTAccess() {
		return pNOT;
	}
	
	public ParserRule getNOTRule() {
		return getNOTAccess().getRule();
	}
	
	//FORALL:
	//	'forall';
	public FORALLElements getFORALLAccess() {
		return pFORALL;
	}
	
	public ParserRule getFORALLRule() {
		return getFORALLAccess().getRule();
	}
	
	//EXISTS:
	//	'exists';
	public EXISTSElements getEXISTSAccess() {
		return pEXISTS;
	}
	
	public ParserRule getEXISTSRule() {
		return getEXISTSAccess().getRule();
	}
	
	//CONJ:
	//	'and';
	public CONJElements getCONJAccess() {
		return pCONJ;
	}
	
	public ParserRule getCONJRule() {
		return getCONJAccess().getRule();
	}
	
	//DISJ:
	//	'or';
	public DISJElements getDISJAccess() {
		return pDISJ;
	}
	
	public ParserRule getDISJRule() {
		return getDISJAccess().getRule();
	}
	
	//IMPL:
	//	'implies';
	public IMPLElements getIMPLAccess() {
		return pIMPL;
	}
	
	public ParserRule getIMPLRule() {
		return getIMPLAccess().getRule();
	}
	
	//BICOND:
	//	'iff';
	public BICONDElements getBICONDAccess() {
		return pBICOND;
	}
	
	public ParserRule getBICONDRule() {
		return getBICONDAccess().getRule();
	}
	
	//INF:
	//	'inf';
	public INFElements getINFAccess() {
		return pINF;
	}
	
	public ParserRule getINFRule() {
		return getINFAccess().getRule();
	}
	
	//IN:
	//	'in';
	public INElements getINAccess() {
		return pIN;
	}
	
	public ParserRule getINRule() {
		return getINAccess().getRule();
	}
	
	//NORM:
	//	'||';
	public NORMElements getNORMAccess() {
		return pNORM;
	}
	
	public ParserRule getNORMRule() {
		return getNORMAccess().getRule();
	}
	
	//PLUS:
	//	'+';
	public PLUSElements getPLUSAccess() {
		return pPLUS;
	}
	
	public ParserRule getPLUSRule() {
		return getPLUSAccess().getRule();
	}
	
	//MINUS:
	//	'-';
	public MINUSElements getMINUSAccess() {
		return pMINUS;
	}
	
	public ParserRule getMINUSRule() {
		return getMINUSAccess().getRule();
	}
	
	//COLON:
	//	':';
	public COLONElements getCOLONAccess() {
		return pCOLON;
	}
	
	public ParserRule getCOLONRule() {
		return getCOLONAccess().getRule();
	}
	
	//SIGN:
	//	PLUS | MINUS;
	public SIGNElements getSIGNAccess() {
		return pSIGN;
	}
	
	public ParserRule getSIGNRule() {
		return getSIGNAccess().getRule();
	}
	
	//OP:
	//	'+' | '-' | '*' | '/';
	public OPElements getOPAccess() {
		return pOP;
	}
	
	public ParserRule getOPRule() {
		return getOPAccess().getRule();
	}
	
	//@Override
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return tML_COMMENT;
	}
	
	//terminal DIGIT:
	//	'0'..'9';
	public TerminalRule getDIGITRule() {
		return tDIGIT;
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
